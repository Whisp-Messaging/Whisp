<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Whisp</title>
<style>
  /* --- SLEEK DARK MODE STYLES --- */
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #121212; /* Dark background */
    color: #e0e0e0;     /* Light text */
    font-family: "Segoe UI", Roboto, sans-serif;
  }
  main {
    height: 100%;
    display: flex;
    flex-direction: column;
    background: #1a1a1a; /* Slightly lighter main container */
  }

  .screen { display: none; flex-direction: column; height: 100%; }
  .screen.active { display: flex; }

  /* Login */
  #loginScreen {
    justify-content: center;
    align-items: center;
    background: #1a1a1a;
    color: #e0e0e0;
    text-align: center;
    padding: 20px;
  }
  #loginScreen h2 { font-size: 2rem; margin-bottom: 20px; color: #008cff; }
  #loginScreen input {
    display: block;
    width: 80%;
    margin: 12px auto;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid #444;
    background: #333;
    color: #fff;
    font-size: 1rem;
  }
  #loginBtn {
    background: #007bff;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    margin-top: 10px;
  }

  /* Chat List */
  #chatListScreen { background: #1a1a1a; flex: 1; }
  #chatListHeader {
    background: #222;
    color: white;
    padding: 14px;
    font-weight: 600;
    border-bottom: 1px solid #333;
    font-size: 1.1rem;
  }
  #chatList { flex: 1; overflow-y: auto; padding-bottom: 70px; }
  .chatItem {
    padding: 16px 14px;
    border-bottom: 1px solid #333;
    cursor: pointer;
    transition: background 0.2s;
    font-size: 1.05rem;
  }
  .chatItem:hover { background: #2c2c2c; }
  .chatItem.unread {
    font-weight: 700;
    background: #2a3a4a; /* Subtle blue for unread */
  }

  /* Bottom Menu */
  #bottomMenu {
    display: flex;
    justify-content: space-around;
    align-items: center;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: #222;
    padding: 10px 0;
    border-top: 1px solid #333;
  }
  #bottomMenu button {
    background: #007bff;
    border: none;
    color: #fff;
    padding: 8px 16px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }

  /* Chat */
  #chatScreen { background: #121212; }
  #chatHeader {
    background: #222;
    color: white;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #chatHeader button { background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; padding: 0 10px; }
  #chatHeader span { font-size: 1.1rem; font-weight: 600; }
  
  #messages { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; }
  .msg {
    max-width: 80%;
    margin-bottom: 10px;
    padding: 10px 14px;
    border-radius: 16px;
    position: relative;
    word-wrap: break-word;
    line-height: 1.4;
  }
  .me {
    align-self: flex-end;
    background: #0056b3; /* Primary accent for "me" */
    color: white;
    border-bottom-right-radius: 4px;
  }
  .them {
    align-self: flex-start;
    background: #333; /* Darker grey for "them" */
    color: #e0e0e0;
    border-bottom-left-radius: 4px;
  }
  .timestamp { font-size: 0.75rem; color: #aaa; text-align: right; margin-top: 4px; }
  .sender { font-size: 0.8rem; color: #0099ff; font-weight: 600; margin-bottom: 3px; }

  /* Reply Bar */
  #replyBar {
    display: none;
    background: #2a2a2a;
    padding: 8px 12px;
    border-left: 4px solid #007bff;
    font-size: 0.9rem;
    align-items: center;
    display: flex;
    justify-content: space-between;
  }
  #replyText { flex: 1; color: #ccc; }
  #cancelReply { background: none; border: none; color: #007bff; font-weight: bold; cursor: pointer; margin-left: 10px; }

  #inputBar {
    display: flex;
    align-items: center;
    background: #222;
    padding: 8px;
    border-top: 1px solid #333;
  }
  #message {
    flex: 1;
    padding: 10px 16px;
    border-radius: 20px;
    border: 1px solid #555;
    background: #333;
    color: #fff;
    outline: none;
    font-size: 1rem;
  }
  #sendBtn {
    background: #007bff;
    color: white;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    margin-left: 8px;
    font-size: 1.2rem;
    cursor: pointer;
  }

  @media (min-width: 700px) {
    main { max-width: 600px; margin: auto; border-radius: 10px; overflow: hidden; }
    #bottomMenu { position: static; }
  }
</style>
</head>
<body>
<main>
  <section id="loginScreen" class="screen active">
    <div>
      <h2>Welcome to Whisp üí¨</h2>
      <input id="email" placeholder="Email" />
      <input id="password" type="password" placeholder="Password" />
      <input id="username" placeholder="Username (for signup)" />
      <button id="loginBtn">Login / Register</button>
    </div>
  </section>

  <section id="chatListScreen" class="screen">
    <div id="chatListHeader">Whisp Chats</div>
    <div id="chatList"></div>
    <div id="bottomMenu">
      <button id="dmBtn">DM</button>
      <button id="groupBtn">Group</button>
      <button id="logoutBtn">Logout</button>
    </div>
  </section>

  <section id="chatScreen" class="screen">
    <div id="chatHeader">
      <button id="backBtn">‚Üê</button>
      <span id="chatName">Chat</span>
    </div>
    <div id="messages"></div>
    <div id="replyBar">
      <span id="replyText"></span>
      <button id="cancelReply">‚úñ</button>
    </div>
    <div id="inputBar">
      <input id="message" placeholder="Type a message..." />
      <button id="sendBtn">‚û§</button>
    </div>
  </section>
</main>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import { getDatabase, ref, set, push, get, onChildAdded, onValue, off, update, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCEdtncZpDgOSnULIjopee7GKh9h9hveKk",
  authDomain: "messagingapp-7ede5.firebaseapp.com",
  databaseURL: "https://messagingapp-7ede5-default-rtdb.firebaseio.com",
  projectId: "messagingapp-7ede5",
  storageBucket: "messagingapp-7ede5.firebasestorage.app",
  messagingSenderId: "221896974865",
  appId: "1:221896974865:web:3faca4885e48ee656907b0"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

const loginScreen=document.getElementById("loginScreen"),
      chatListScreen=document.getElementById("chatListScreen"),
      chatScreen=document.getElementById("chatScreen"),
      chatList=document.getElementById("chatList"),
      messagesDiv=document.getElementById("messages"),
      replyBar=document.getElementById("replyBar"),
      replyText=document.getElementById("replyText"),
      cancelReplyBtn=document.getElementById("cancelReply"),
      messageInput=document.getElementById("message");

let currentUser=null, currentChatId=null, replyTo=null, currentListenerRef=null;
let currentChatIsGroup=false, chatMembers={};

let activeMessageListeners = new Set();

const show=(s)=>{[loginScreen,chatListScreen,chatScreen].forEach(e=>e.classList.remove("active"));s.classList.add("active");};

// --- LOGIN HANDLER (SIMPLIFIED) ---
document.getElementById("loginBtn").onclick = async () => {
  const emailVal = document.getElementById("email").value.trim();
  const passwordVal = document.getElementById("password").value.trim();
  const usernameVal = document.getElementById("username").value.trim();
  if(!emailVal || !passwordVal) return alert("Enter credentials.");
  
  try {
    let cred;
    try {
      // Attempt login first
      cred = await signInWithEmailAndPassword(auth, emailVal, passwordVal);
    } catch (e) {
      // If login fails, attempt registration
      if(!usernameVal) return alert("Please provide a username for registration.");
      
      cred = await createUserWithEmailAndPassword(auth, emailVal, passwordVal);
      
      const finalUsername = usernameVal || emailVal.split("@")[0];
      const uid = cred.user.uid;
      
      // Set user profile (for DM lookups)
      await set(ref(db, "users/" + uid), { 
        username: finalUsername, 
        email: emailVal 
      });
    }
  } catch (e) {
    alert(e.message);
  }
};

onAuthStateChanged(auth, async user => {
  if(user){
    currentUser=user;
    activeMessageListeners = new Set();
    await loadChats();
    show(chatListScreen);
    listenForUnread();
  } else {
    currentUser=null;
    activeMessageListeners.forEach(chatId => {
      try { off(ref(db,"chats/"+chatId+"/messages")); } catch(_) {}
    });
    activeMessageListeners.clear();
    show(loginScreen);
  }
});

// --- LOAD CHATS (DM NAMING FIXES APPLIED) ---
async function loadChats(){
  chatList.innerHTML="";
  const chatsSnap = await get(ref(db,"chats"));
  if(!chatsSnap.exists()) return;

  const chats = chatsSnap.val();
  const chatPromises = Object.keys(chats).map(async (id) => {
    const chat = chats[id];
    
    // Check membership using Object Map keys
    if(!chat.members || !chat.members[currentUser.uid]) {
      return null;
    }

    let chatName = chat.name;
    const isDM = chat.isGroup === false;
    
    // If it's a DM, find the other user and get their username
    if (isDM) {
      const memberUids = Object.keys(chat.members);
      const otherUid = memberUids.find(uid => uid !== currentUser.uid);
      if (otherUid) {
        try {
          const userSnap = await get(ref(db, "users/" + otherUid));
          if (userSnap.exists()) {
            chatName = userSnap.val().username || "DM"; 
          } else {
            chatName = "Deleted User";
          }
        } catch (e) {
          chatName = chat.name || "DM"; 
        }
      }
    }

    return { id, name: chatName };
  });

  const chatItems = await Promise.all(chatPromises);

  // Now render them
  chatItems.forEach(item => {
    if (!item) return; 
    
    const div = document.createElement("div");
    div.className = "chatItem";
    div.dataset.id = item.id;
    div.textContent = item.name; 
    div.onclick = () => openChat(item.id, item.name); 
    chatList.append(div);
  });
}

// --- OPEN CHAT (MEMBER ITERATION FIXES APPLIED) ---
async function openChat(id,name){
  currentChatId=id;
  document.getElementById("chatName").textContent=name;
  messagesDiv.innerHTML="";
  chatMembers = {}; 
  show(chatScreen);

  if(currentListenerRef){ off(currentListenerRef); currentListenerRef=null; }

  const chatSnap=await get(ref(db,"chats/"+id));
  if (!chatSnap.exists()) return;
  
  const chat=chatSnap.val();
  currentChatIsGroup = chat.isGroup || false;

  // load member usernames by iterating over the object map keys
  if(chat.members){
    for(const uid of Object.keys(chat.members)){
      try {
        const uSnap = await get(ref(db,"users/"+uid));
        if(uSnap.exists()) chatMembers[uid] = uSnap.val().username || "Unknown";
      } catch(e) {
        chatMembers[uid] = "Unknown";
      }
    }
  }

  // mark messages as read and set lastRead
  await update(ref(db,"userChats/"+currentUser.uid+"/"+id), {
    unread: false,
    lastRead: Date.now()
  });

  // close any existing system notifications
  if("serviceWorker" in navigator){
    navigator.serviceWorker.getRegistration().then(reg=>{
      if(!reg) return;
      reg.getNotifications({ tag: id }).then(list=>{
        list.forEach(n => n.close());
      }).catch(()=>{});
    }).catch(()=>{});
  }

  const msgRef=ref(db,"chats/"+id+"/messages");
  currentListenerRef=msgRef;
  onChildAdded(msgRef,s=>renderMessage(s.val()));
}

// --- RENDER MESSAGE (SWIPE TO REPLY ADDED) ---
function renderMessage(m){
  const div=document.createElement("div");
  div.classList.add("msg",m.sender===currentUser.uid?"me":"them");

  let senderLabel="";
  if(currentChatIsGroup && m.sender!==currentUser.uid){
    const uname=chatMembers[m.sender]||"Unknown";
    senderLabel=`<div class="sender">${uname}</div>`;
  }

  // Simple link detection (basic)
  const linkedText = m.text.replace(
      /(https?:\/\/[^\s]+)/g,
      '<a href="$1" target="_blank" style="color: inherit;">$1</a>'
  );

  div.innerHTML=`
    ${senderLabel}
    ${m.replyTo?`<div style="font-size:0.85rem;color:#bbb;border-left:3px solid #007bff;padding-left:6px;margin-bottom:3px;opacity:0.8;">${m.replyTo.slice(0, 50)}...</div>`:""}
    ${linkedText}
    <div class="timestamp">${new Date(m.time).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</div>
  `;
  messagesDiv.append(div);
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // --- SWIPE TO REPLY LOGIC ---
  div.addEventListener("touchstart", e => {
    if (e.touches.length === 1) {
      div.startX = e.touches[0].clientX;
      div.isDragging = false;
    }
  });
  
  div.addEventListener("touchmove", e => {
    if (!div.startX) return;
    const diff = e.touches[0].clientX - div.startX;
    
    // Check for a minimum horizontal drag distance
    if (diff > 70) {
      div.isDragging = true;
    }
  });

  div.addEventListener("touchend", () => {
    if (div.isDragging) {
      showReplyBar(m.text);
      div.isDragging = false;
    }
    div.startX = null;
  });
  
  // Also allow a quick click/tap to initiate a reply
  div.addEventListener("click", () => {
      if (!div.isDragging) showReplyBar(m.text);
  });
  // --- END SWIPE TO REPLY LOGIC ---
}

function showReplyBar(text){
  replyTo=text;
  replyBar.style.display="flex";
  replyText.textContent="Replying to: "+text.slice(0,40);
}

cancelReplyBtn.onclick=()=>{
  replyTo=null;
  replyBar.style.display="none";
};

document.getElementById("sendBtn").onclick=async()=>{
  const text=messageInput.value.trim();
  if(!text||!currentChatId) return;
  await push(ref(db,"chats/"+currentChatId+"/messages"),{sender:currentUser.uid,text,replyTo,time:Date.now()});
  messageInput.value="";
  replyTo=null;
  replyBar.style.display="none";
};

document.getElementById("backBtn").onclick=()=>{
  currentChatId=null;
  if(currentListenerRef){off(currentListenerRef); currentListenerRef=null;}
  loadChats(); 
  show(chatListScreen);
};

document.getElementById("logoutBtn").onclick=async()=>{
  await signOut(auth);
  currentUser=null;
  show(loginScreen);
};

// --- HELPER FUNCTION TO FIND USER BY USERNAME (for simplified search) ---
async function findUserByUsername(username) {
  const usersRef = ref(db, 'users');
  // Query users where username is equal to the input
  const q = query(usersRef, orderByChild('username'), equalTo(username));
  const snap = await get(q);
  
  let result = null;
  if (snap.exists()) {
    // Return the first user found (should only be one if usernames are unique)
    snap.forEach(child => {
      result = { uid: child.key, ...child.val() };
    });
  }
  return result;
}

// --- GROUP BUTTON (SIMPLIFIED) ---
document.getElementById("groupBtn").onclick=async()=>{
  const name=prompt("Group name:");
  if(!name)return;
  const input=prompt("Enter usernames (comma-separated):");
  const usernames=input?input.split(",").map(u=>u.trim()):[];
  if (usernames.length === 0) return alert("Group must have members.");

  const memberIds=[currentUser.uid];
  
  // Look up each user
  for (const uname of usernames) {
    const user = await findUserByUsername(uname);
    if (user) {
      if (user.uid !== currentUser.uid && !memberIds.includes(user.uid)) {
        memberIds.push(user.uid);
      }
    } else {
      console.warn(`User "${uname}" not found. Skipping.`);
    }
  }
  
  if (memberIds.length < 2) return alert("Could not find any other valid users to add.");

  // Convert the memberIds array to the required object map
  const newMembersMap = memberIds.reduce((map, uid) => {
      map[uid] = true;
      return map;
  }, {});

  const refNew=push(ref(db,"chats"));
  await set(refNew,{
    name,
    isGroup:true,
    members:newMembersMap
  });
  
  // Store chat metadata for all members
  const userChatUpdates = {};
  memberIds.forEach(uid => {
    userChatUpdates[`/userChats/${uid}/${refNew.key}`] = { name: name, isGroup: true };
  });
  await update(ref(db), userChatUpdates);

  loadChats();
};

// --- DM BUTTON (SIMPLIFIED) ---
document.getElementById("dmBtn").onclick=async()=>{
  const uname = prompt("Username to DM:");
  if (!uname) return;

  try {
    // 1. Look up the UID from the 'users' path
    const otherUser = await findUserByUsername(uname);
    if (!otherUser) {
      return alert("User not found.");
    }
    const otherUid = otherUser.uid;

    if (otherUid === currentUser.uid) {
      return alert("You can't DM yourself!");
    }

    // 2. Create the chat using Object Map for members
    const refNew = push(ref(db, "chats"));
    const newMembersMap = { [currentUser.uid]: true, [otherUid]: true };
    
    await set(refNew, {
      name: uname, 
      isGroup: false,
      members: newMembersMap
    });
    
    // 3. Store chat metadata for both members
    const currentUserProfileSnap = await get(ref(db, "users/" + currentUser.uid));
    const currentUsername = currentUserProfileSnap.val() ? currentUserProfileSnap.val().username : "You";

    await update(ref(db), {
      // User's side shows the *other* user's name
      [`/userChats/${currentUser.uid}/${refNew.key}`]: { name: uname, isGroup: false }, 
      // Other user's side shows *your* username
      [`/userChats/${otherUid}/${refNew.key}`]: { name: currentUsername, isGroup: false } 
    });

    loadChats();

  } catch (e) {
    alert("Error creating DM: " + e.message);
  }
};

// --- LISTEN FOR UNREAD (MEMBERSHIP CHECK FIXES APPLIED) ---
function listenForUnread(){
  // watch userChats to update UI unread markers
  const userChatsRef = ref(db,"userChats/"+currentUser.uid);
  onValue(userChatsRef,snap=>{
    if(!snap.exists()) return;
    snap.forEach(child=>{
      const chatId=child.key;
      const data=child.val();
      const chatDiv=[...chatList.children].find(d=>d.dataset.id===chatId);
      if(chatDiv){
        if(data.unread) chatDiv.classList.add("unread");
        else chatDiv.classList.remove("unread");
      }
    });
  });

  // iterate chats once and attach one message listener per chat
  onValue(ref(db,"chats"), snap => {
    if(!snap.exists()) return;
    snap.forEach(chatSnap => {
      const chatId = chatSnap.key;
      const chat = chatSnap.val();
      
      // Check membership using Object Map keys
      if(!chat.members || !chat.members[currentUser.uid]) return;

      if(activeMessageListeners.has(chatId)) return;
      activeMessageListeners.add(chatId);

      const msgRef = ref(db,"chats/"+chatId+"/messages");
      onChildAdded(msgRef, msgSnap => {
        const m = msgSnap.val();

        // ignore our own messages
        if(!m || !m.sender || m.sender === currentUser.uid) return;

        // check user's lastRead for this chat
        get(ref(db,"userChats/"+currentUser.uid+"/"+chatId)).then(userChatSnap=>{
          const data = userChatSnap.val() || {};
          const lastRead = data.lastRead || 0;

          // only mark unread and notify if message is newer than lastRead and chat not open
          if(m.time > lastRead && currentChatId !== chatId){
            update(ref(db,"userChats/"+currentUser.uid+"/"+chatId),{ unread:true });

            // show push notification
            showNotification(chat.name || "New message", m.text, chatId);
          }
        }).catch(()=>{});
      });
    });
  });
}

// service worker registration and permission
if("serviceWorker" in navigator){
  navigator.serviceWorker.register("sw.js").then(()=> {
    if(Notification.permission !== "granted" && Notification.permission !== "denied"){
      Notification.requestPermission();
    }
  }).catch(()=>{});
}

function showNotification(title, body, tag){
  if(!("Notification" in window)) return;
  if(Notification.permission === "granted" && "serviceWorker" in navigator){
    navigator.serviceWorker.ready.then(reg => {
      try {
        reg.showNotification(title, {
          body,
          icon: "https://cdn-icons-png.flaticon.com/512/906/906349.png",
          tag
        });
      } catch(e){}
    }).catch(()=>{});
  } else if(Notification.permission !== "denied"){
    Notification.requestPermission().then(p => {
      if(p === "granted"){
        try { new Notification(title, { body, icon: "https://cdn-icons-png.flaticon.com/512/906/906349.png", tag }); } catch(e) {}
      }
    });
  }
}
</script>
</body>
</html>
