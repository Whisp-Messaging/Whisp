<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Whisp Messenger</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  /* --- GLOBAL & BASE STYLES --- */
  :root {
    --color-bg-dark: #0A0A0A;
    --color-bg-mid: #141414;
    --color-bg-light: #1F1F1F;
    --color-text-primary: #EAEAEA;
    --color-text-secondary: #999999;
    --color-accent-blue: #007AFF; /* iOS-inspired blue */
    --color-accent-green: #34C759; /* Online status */
    --color-accent-typing: #5AC8FA;
    --color-border: #2C2C2E;
  }
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: var(--color-bg-dark);
    color: var(--color-text-primary);
    font-family: 'Inter', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  main {
    height: 100%;
    width: 100%;
    display: flex;
    flex-direction: column;
    background: var(--color-bg-mid);
    max-width: 600px; /* Center chat view on larger screens */
    margin: 0 auto;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
  }

  .screen { 
    display: none; 
    flex-direction: column; 
    height: 100%; 
  }
  .screen.active { 
    display: flex; 
  }
  
  /* --- 1. LOGIN SCREEN --- */
  #loginScreen {
    justify-content: center;
    align-items: center;
    background: var(--color-bg-mid);
  }
  #loginScreen h2 { 
    font-size: 2.5rem; 
    margin-bottom: 30px; 
    color: var(--color-accent-blue); 
    font-weight: 700;
  }
  #loginScreen input {
    display: block;
    width: 90%;
    max-width: 350px; 
    margin: 15px auto;
    padding: 16px;
    border-radius: 12px; 
    border: 1px solid var(--color-border);
    background: var(--color-bg-light);
    color: var(--color-text-primary);
    font-size: 1.1rem;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
  }
  #loginBtn {
    background: var(--color-accent-blue);
    color: white;
    border: none;
    padding: 14px 40px;
    border-radius: 12px;
    cursor: pointer;
    font-weight: 600;
    font-size: 1.2rem;
    transition: background 0.3s, transform 0.1s;
    margin-top: 25px;
  }
  #loginBtn:hover { background: #005bb8; }
  #loginBtn:active { transform: scale(0.98); }

  /* --- 2. CHAT LIST SCREEN --- */
  #chatListScreen { background: var(--color-bg-mid); flex: 1; }
  #chatListHeader {
    background: var(--color-bg-mid);
    color: var(--color-text-primary);
    padding: 16px 20px;
    font-weight: 700;
    border-bottom: 1px solid var(--color-border);
    font-size: 1.4rem;
  }
  #chatList { 
    flex: 1; 
    overflow-y: auto; 
    padding: 0; /* Remove top padding */
    padding-bottom: 70px; 
  }
  .chatItem {
    padding: 15px 20px; 
    border-bottom: 1px solid var(--color-border);
    cursor: pointer;
    transition: background 0.2s;
    font-size: 1.1rem; 
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .chatItem:hover { background: var(--color-bg-light); }
  .chatItem.unread {
    font-weight: 600;
    background: #1A1A2A; 
    border-left: 4px solid var(--color-accent-blue);
    padding-left: 16px;
  }
  .chatItem .lastMessage {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
      max-width: 90%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      margin-top: 4px;
  }

  /* Bottom Menu */
  #bottomMenu {
    display: flex;
    justify-content: space-around; 
    align-items: center;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: var(--color-bg-mid);
    padding: 10px 0; 
    border-top: 1px solid var(--color-border);
    z-index: 10;
    max-width: 600px;
    transform: translateX(0);
    left: 50%;
    transform: translateX(-50%);
  }
  #bottomMenu button {
    background: var(--color-accent-blue);
    color: white;
    border: none;
    padding: 8px 16px; 
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.3s;
    font-size: 0.95rem;
  }
  #bottomMenu button:hover { background: #005bb8; }
  
  /* --- 3. CHAT SCREEN --- */
  #chatScreen { background: var(--color-bg-dark); position: relative; } 
  #chatHeader {
    background: var(--color-bg-mid);
    color: var(--color-text-primary);
    padding: 10px 10px; 
    display: flex;
    flex-direction: column; 
    border-bottom: 1px solid var(--color-border);
    box-shadow: 0 1px 5px rgba(0,0,0,0.3);
  }
  #chatHeader button { 
    background: none; 
    border: none; 
    color: var(--color-accent-blue); 
    font-size: 1.5rem; 
    cursor: pointer; 
    padding: 0 5px; 
    transition: color 0.2s;
  }
  #chatHeader button:hover { color: #5AC8FA; }
  
  #chatHeader div.main-row { 
    width: 100%; 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
  }
  #chatNameContainer { 
    display: flex; 
    flex-direction: column; 
    align-items: flex-start; 
    flex-grow: 1;
    margin-left: 10px;
  }
  #chatName { 
    font-size: 1.2rem; 
    font-weight: 600; 
  }

  /* Status Styles */
  #chatStatus { 
    font-size: 0.8rem; 
    color: var(--color-text-secondary); 
    height: 16px; 
    font-weight: 400;
  }
  #chatStatus.online { 
    color: var(--color-accent-green); 
    font-weight: 500;
  } 

  /* Typing Indicator Style */
  #typingIndicator { 
    font-size: 0.85rem; 
    color: var(--color-accent-typing); 
    font-style: italic;
    height: 20px; 
    text-align: left;
    padding: 3px 0 0 50px; 
    width: 100%;
    overflow: hidden;
  }
  
  #messages { 
    flex: 1; 
    overflow-y: auto; 
    padding: 10px 15px; 
    display: flex; 
    flex-direction: column; 
    gap: 8px;
  }
  .msg {
    max-width: 85%; 
    padding: 12px 16px; 
    border-radius: 18px; 
    position: relative;
    word-wrap: break-word;
    line-height: 1.4;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  }
  .me {
    align-self: flex-end;
    background: var(--color-accent-blue); 
    color: white;
    border-bottom-right-radius: 6px;
  }
  .them {
    align-self: flex-start;
    background: var(--color-bg-light); 
    color: var(--color-text-primary);
    border-bottom-left-radius: 6px;
  }

  .timestamp { 
    font-size: 0.7rem; 
    color: rgba(255,255,255,0.7); 
    text-align: right; 
    margin-top: 4px; 
    display: block;
    opacity: 0.8;
  }
  .them .timestamp {
    color: rgba(224,224,224,0.7);
  }
  .sender { 
    font-size: 0.9rem; 
    color: var(--color-accent-typing); 
    font-weight: 600; 
    margin-bottom: 4px; 
  }
  .msg a { color: inherit; text-decoration: underline; }


  /* Reply Bar */
  #replyBar {
    display: none;
    background: var(--color-bg-light);
    padding: 8px 15px; 
    border-left: 4px solid var(--color-accent-blue);
    font-size: 0.95rem;
    align-items: center;
    display: flex;
    justify-content: space-between;
    color: var(--color-text-secondary);
  }
  #replyText { flex: 1; color: var(--color-text-primary); }
  #cancelReply { 
    background: none; 
    border: none; 
    color: var(--color-accent-blue); 
    font-weight: bold; 
    cursor: pointer; 
    margin-left: 10px; 
    font-size: 1.2rem;
  }

  #inputBar {
    display: flex;
    align-items: flex-end; 
    background: var(--color-bg-mid);
    padding: 10px 15px; 
    border-top: 1px solid var(--color-border);
  }

  #message {
    flex: 1;
    padding: 12px 18px; 
    border-radius: 24px;
    border: none;
    background: var(--color-bg-light);
    color: var(--color-text-primary);
    outline: none;
    font-size: 1rem;
    resize: none;
    max-height: 100px; 
    overflow-y: auto;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
  }
  #sendBtn {
    background: var(--color-accent-blue);
    color: white;
    border: none;
    border-radius: 50%;
    width: 48px; 
    height: 48px; 
    margin-left: 10px;
    font-size: 1.5rem;
    cursor: pointer;
    transition: background 0.3s, transform 0.1s;
  }
  #sendBtn:hover { background: #005bb8; }
  #sendBtn:active { transform: scale(0.95); }

  /* Group Settings Menu Style */
  #settingsBtn {
    margin-left: 10px;
    font-size: 1.3rem !important;
    display: none; 
  }

  #groupSettingsMenu {
    position: absolute;
    top: 65px; 
    right: 15px;
    background: var(--color-bg-light);
    border: 1px solid var(--color-border);
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    z-index: 20;
    overflow: hidden;
    display: none;
  }
  #groupSettingsMenu button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 12px 20px;
    background: none;
    border: none;
    color: var(--color-text-primary);
    cursor: pointer;
    font-size: 1rem;
    transition: background 0.2s;
  }
  #groupSettingsMenu button:hover {
    background: #2A2A2A;
  }
</style>
</head>
<body>
<main>
  <section id="loginScreen" class="screen active">
    <div>
      <h2>Welcome to Whisp üí¨</h2>
      <input id="email" placeholder="Email" />
      <input id="password" type="password" placeholder="Password" />
      <input id="username" placeholder="Username (for signup)" />
      <button id="loginBtn">Login / Register</button>
    </div>
  </section>

  <section id="chatListScreen" class="screen">
    <div id="chatListHeader">Whisp Chats</div>
    <div id="chatList"></div>
    <div id="bottomMenu">
      <button id="newDmBtn">New DM</button> 
      <button id="groupBtn">New Group</button>
      <button id="logoutBtn">Logout</button>
    </div>
  </section>
  
  <section id="chatScreen" class="screen">
    <div id="chatHeader">
      <div class="main-row">
        <button id="backBtn">‚Üê</button>
        <div id="chatNameContainer">
            <span id="chatName">Chat</span>
            <span id="chatStatus"></span>
        </div>
        <button id="settingsBtn" style="display: none;">‚ãÆ</button>
      </div>
      <div id="typingIndicator"></div>
    </div>
    
    <div id="groupSettingsMenu">
        <button id="renameGroupBtn">Rename Group</button>
        <button id="addMembersBtn">Add Members</button>
    </div>

    <div id="messages"></div>
    <div id="replyBar">
      <span id="replyText"></span>
      <button id="cancelReply">‚úñ</button>
    </div>
    <div id="inputBar">
      <textarea id="message" placeholder="Type a message..."></textarea>
      <button id="sendBtn">‚û§</button>
    </div>
  </section>
</main>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import { getDatabase, ref as dbRef, set, push, get, onChildAdded, onValue, off, update, remove, onDisconnect, query, limitToLast } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";


const firebaseConfig = {
  apiKey: "AIzaSyCEdtncZpDgOSnULIjopee7GKh9h9hveKk",
  authDomain: "messagingapp-7ede5.firebaseapp.com",
  databaseURL: "https://messagingapp-7ede5-default-rtdb.firebaseio.com",
  projectId: "messagingapp-7ede5",
  messagingSenderId: "221896974865",
  appId: "1:221896974865:web:3faca4885e48ee656907b0"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

const loginScreen=document.getElementById("loginScreen"),
      chatListScreen=document.getElementById("chatListScreen"),
      chatScreen=document.getElementById("chatScreen"),
      chatList=document.getElementById("chatList"),
      messagesDiv=document.getElementById("messages"),
      replyBar=document.getElementById("replyBar"),
      replyText=document.getElementById("replyText"),
      cancelReplyBtn=document.getElementById("cancelReply"),
      messageInput=document.getElementById("message"),
      typingIndicator=document.getElementById("typingIndicator"),
      chatStatus=document.getElementById("chatStatus"),
      settingsBtn = document.getElementById("settingsBtn"),
      groupSettingsMenu = document.getElementById("groupSettingsMenu");

let currentUser=null, currentChatId=null, replyTo=null, currentListenerRef=null, otherUserUid=null; 
let currentChatIsGroup=false, chatMembers={};
let typingTimer=null, typingStatusRef=null, currentTypingListener = null;

let activeMessageListeners = new Set();

const show=(s)=>{[loginScreen,chatListScreen,chatScreen].forEach(e=>e.classList.remove("active"));s.classList.add("active");}; 

// --- PRESENCE HANDLERS ---

function formatLastSeen(timestamp) {
    if (!timestamp) return "";
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    if (diff < 60000) return "just now";
    if (diff < 3600000) return `Last seen ${Math.floor(diff / 60000)}m ago`;
    if (date.toDateString() === now.toDateString()) return `Last seen today at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (date.toDateString() === yesterday.toDateString()) return `Last seen yesterday at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    
    return `Last seen ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
}

async function goOnline() {
    if (!currentUser) return;
    const isOnlineRef = dbRef(db, 'presence/' + currentUser.uid);

    await set(isOnlineRef, true);
    onDisconnect(isOnlineRef).set(Date.now());
}

async function goOffline() {
    if (!currentUser) return;
    const isOnlineRef = dbRef(db, 'presence/' + currentUser.uid);

    onDisconnect(isOnlineRef).cancel();
    await set(isOnlineRef, Date.now());
}

// --- LOGIN HANDLER ---
document.getElementById("loginBtn").onclick = async () => {
  const emailVal = document.getElementById("email").value.trim();
  const passwordVal = document.getElementById("password").value.trim();
  const usernameVal = document.getElementById("username").value.trim();
  if(!emailVal || !passwordVal) return alert("Enter credentials.");
  
  try {
    let cred;
    try {
      // 1. Attempt login 
      cred = await signInWithEmailAndPassword(auth, emailVal, passwordVal);
      return; 
    } catch (e) {
      // 2. If login fails, attempt registration
      if(!usernameVal) {
        return alert("Login failed. If you are registering, please provide a username.");
      }
      
      const finalUsername = usernameVal || emailVal.split("@")[0];
      const normalizedUsername = finalUsername.toLowerCase();

      // --- UNIQUENESS CHECK ---
      const usersRef = dbRef(db, 'users');
      const snap = await get(usersRef);
      if (snap.exists()) {
        const users = snap.val();
        for (const uid in users) {
          const storedUsername = users[uid].username;
          if (storedUsername && storedUsername.toLowerCase() === normalizedUsername) {
            return alert(`The username "${finalUsername}" is already taken. Please choose another.`);
          }
        }
      }
      // --- END UNIQUENESS CHECK ---
      
      // 3. Create user
      cred = await createUserWithEmailAndPassword(auth, emailVal, passwordVal);
      
      const uid = cred.user.uid;
      
      // 4. Set user profile
      await set(dbRef(db, "users/" + uid), { 
        username: finalUsername, 
        email: emailVal 
      });
    }
  } catch (e) {
    alert(e.message);
  }
};

onAuthStateChanged(auth, async user => {
  if(user){
    currentUser=user;
    activeMessageListeners = new Set();
    await loadChats();
    goOnline(); 
    show(chatListScreen);
    listenForUnread();
  } else {
    currentUser=null;
    activeMessageListeners.forEach(chatId => {
      try { off(dbRef(db,"chats/"+chatId+"/messages")); } catch(_) {}
    });
    activeMessageListeners.clear();
    show(loginScreen);
  }
});

// --- LOAD CHATS ---
async function loadChats(){
  chatList.innerHTML="";
  
  const userChatsSnap = await get(dbRef(db, `userChats/${currentUser.uid}`));
  if(!userChatsSnap.exists()) return;

  const chatPromises = [];
  userChatsSnap.forEach(chatChild => {
      const chatId = chatChild.key;
      const data = chatChild.val(); 
      
      const chatPromise = get(dbRef(db, `chats/${chatId}`)).then(async chatSnap => {
          if (!chatSnap.exists()) return null;
          
          const chat = chatSnap.val();
          
          let isMember = false;
          let memberUids = [];
          
          if (chat.members) {
            if (Array.isArray(chat.members)) {
              memberUids = chat.members;
            } else if (typeof chat.members === 'object') {
              memberUids = Object.keys(chat.members);
            }
            isMember = memberUids.includes(currentUser.uid);
          }

          if(!isMember) return null;
          
          let chatName = data.name; 
          let isDM = data.isGroup === false;
          
          if (!isDM && memberUids.length === 2 && chat.isGroup !== true) {
              isDM = true;
          }
          let updateNeeded = false; 

          // --- CRITICAL FIX: OVERRIDE DM NAME (Uses stored otherUid first) ---
          let finalOtherUid = data.otherUid;
          if (!finalOtherUid && isDM) {
              finalOtherUid = memberUids.find(uid => uid !== currentUser.uid);
          }

          if (isDM && finalOtherUid) { 
              const userSnap = await get(dbRef(db, "users/" + finalOtherUid));
              if (userSnap.exists()) {
                  const correctName = userSnap.val().username || "DM User"; 
                  chatName = correctName; 
                  
                  if (data.name !== correctName || !data.name || !data.otherUid) { 
                      updateNeeded = true;    
                  }
                  chatMembers[finalOtherUid] = correctName; // Update chatMembers for typing indicator
              } else {
                  chatName = "Deleted User";
                  if (data.name !== chatName || !data.name) updateNeeded = true;
              }
          } else if (isDM && !finalOtherUid) {
              chatName = "DM Setup Error";
          }
          // --- END CRITICAL FIX ---
          
          // --- Get Last Message Snippet ---
          let lastMessageText = data.lastMessageText || "No messages yet";
          if (!data.lastMessageText) {
             const messagesQuery = query(dbRef(db, `chats/${chatId}/messages`), limitToLast(1));
             const msgSnap = await get(messagesQuery);
             if (msgSnap.exists()) {
                 let lastMsg = null;
                 msgSnap.forEach(child => lastMsg = child.val());
                 if (lastMsg) {
                     lastMessageText = lastMsg.text || "Message"; 
                 }
             }
          }

          return { 
              id: chatId, 
              name: chatName, 
              lastTime: data.lastMessageTime || 0,
              unread: data.unread,
              updateNeeded: updateNeeded,
              lastMessageText: lastMessageText
          };
      });
      chatPromises.push(chatPromise);
  });

  const chatItems = (await Promise.all(chatPromises)).filter(item => item !== null);
  chatItems.sort((a, b) => b.lastTime - a.lastTime);

  const correctionPromises = [];
  chatItems.forEach(item => {
    const div = document.createElement("div");
    div.className = "chatItem";
    div.dataset.id = item.id;
    
    div.innerHTML = `
        <div>
            ${item.name}
            <div class="lastMessage">${item.lastMessageText}</div>
        </div>
    `;
    
    if(item.unread) div.classList.add("unread"); 
    div.onclick = () => openChat(item.id, item.name); 
    chatList.append(div);
    
    // 4. Perform the correction if needed
    if (item.updateNeeded) {
        const updateData = { name: item.name };
        if (item.id.otherUid) updateData.otherUid = item.id.otherUid; // Only set if available
        correctionPromises.push(
            update(dbRef(db, `/userChats/${currentUser.uid}/${item.id}`), updateData)
        );
    }
  });
  
  await Promise.all(correctionPromises).catch(e => console.error("Error during chat name correction:", e));
}

// --- TYPING INDICATOR HANDLERS ---
function startTyping(){
    if(!currentChatId || !currentUser) return;
    if(typingTimer) clearTimeout(typingTimer);

    typingStatusRef = dbRef(db, "typing/" + currentChatId + "/" + currentUser.uid);
    set(typingStatusRef, Date.now()).catch(()=>{});
    typingTimer = setTimeout(stopTyping, 2000);
}

function stopTyping(){
    if(typingTimer) clearTimeout(typingTimer);
    if(typingStatusRef) remove(typingStatusRef).catch(()=>{});
    typingTimer = null;
    typingStatusRef = null;
}

// --- OPEN CHAT ---
async function openChat(id,name){
  stopTyping(); 
  
  currentChatId=id;
  document.getElementById("chatName").textContent=name;
  messagesDiv.innerHTML="";
  typingIndicator.textContent = ""; 
  chatStatus.textContent = ""; 
  chatStatus.classList.remove("online");
  chatMembers = {}; 
  otherUserUid = null; 
  groupSettingsMenu.style.display = 'none'; 
  settingsBtn.style.display = 'none'; 

  // Clean up old message listener
  if(currentListenerRef){ off(currentListenerRef); currentListenerRef=null; }
  // Clean up old typing listener
  if(currentTypingListener){ off(currentTypingListener); currentTypingListener = null; }

  show(chatScreen);

  const chatSnap=await get(dbRef(db,"chats/"+id));
  if (!chatSnap.exists()) return;
  
  const chat=chatSnap.val();
  currentChatIsGroup = chat.isGroup || false;
  
  if (currentChatIsGroup) { 
      settingsBtn.style.display = 'block';
  }

  // Determine otherUserUid from userChats data (more reliable)
  const userChatSnap = await get(dbRef(db, `userChats/${currentUser.uid}/${id}`));
  const userChatData = userChatSnap.val();
  if (userChatData && userChatData.otherUid) {
      otherUserUid = userChatData.otherUid;
  }
  
  // load member usernames
  if(chat.members){
    const memberUids = Array.isArray(chat.members) ? chat.members : Object.keys(chat.members);
    
    // Fallback if otherUid wasn't stored in userChats (old chats)
    if (!otherUserUid && !currentChatIsGroup && memberUids.length === 2) {
        otherUserUid = memberUids.find(uid => uid !== currentUser.uid);
    }

    for(const uid of memberUids){
      try {
        const uSnap = await get(dbRef(db,"users/"+uid));
        if(uSnap.exists()) chatMembers[uid] = uSnap.val().username || "Unknown";
      } catch(e) {
        chatMembers[uid] = "Unknown";
      }
    }
  }
  
  // --- Presence Listener for DM Status ---
  if (otherUserUid) {
      const presenceRef = dbRef(db, 'presence/' + otherUserUid);
      onValue(presenceRef, (snapshot) => {
          if (!snapshot.exists()) {
              chatStatus.textContent = "";
              chatStatus.classList.remove("online");
              return;
          }
          
          const status = snapshot.val();
          
          if (status === true) {
              chatStatus.textContent = "Online";
              chatStatus.classList.add("online");
          } else if (typeof status === 'number') {
              chatStatus.textContent = `Last seen ${formatLastSeen(status)}`;
              chatStatus.classList.remove("online");
          } else {
              chatStatus.textContent = "";
              chatStatus.classList.remove("online");
          }
      });
  } else if (!currentChatIsGroup) {
      chatStatus.textContent = "User status unavailable";
  } else {
      chatStatus.textContent = "";
  }
  // --- End Presence Listener ---


  // --- TYPING INDICATOR LISTENER (FIXED LOGIC) ---
  const typingRef = dbRef(db, "typing/" + id);
  
  // Clean up any previous listener before setting the new one
  if(currentTypingListener){ 
    off(currentTypingListener); 
    currentTypingListener = null; 
  }

  // Store the listener's off function (reference to the listener itself)
  currentTypingListener = onValue(typingRef, (snapshot) => {
      // **CRITICAL GUARD CLAUSE: Only update UI if user is viewing THIS chat**
      if (currentChatId !== id) {
          return;
      }
      
      if(!snapshot.exists()) {
          typingIndicator.textContent = "";
          return;
      }
      
      const typingUsers = [];
      const now = Date.now();
      
      snapshot.forEach((child) => {
          const uid = child.key;
          const timestamp = child.val();
          
          // Check if the user is typing AND is not the current user, AND the timestamp is fresh (within 2 seconds)
          if(uid !== currentUser.uid && (now - timestamp) < 2000) {
              const uname = chatMembers[uid] || "Someone";
              typingUsers.push(uname);
          }
      });
      
      if(typingUsers.length > 0) {
          if(typingUsers.length === 1) {
              // Only show the name in a group chat; for DM, the header already implies the user
              const nameToDisplay = currentChatIsGroup ? typingUsers[0] : "";
              typingIndicator.textContent = `${nameToDisplay} is typing...`.trim();
          } else if(typingUsers.length === 2) {
              typingIndicator.textContent = `${typingUsers.join(' and ')} are typing...`;
          } else {
              typingIndicator.textContent = `Multiple users are typing...`;
          }
      } else {
          typingIndicator.textContent = "";
      }
  });
  // --- END TYPING INDICATOR LISTENER ---


  // mark messages as read and set lastRead
  await update(dbRef(db,"userChats/"+currentUser.uid+"/"+id), {
    unread: false,
    lastRead: Date.now()
  });

  // close any existing system notifications
  if("serviceWorker" in navigator){
    navigator.serviceWorker.getRegistration().then(reg=>{
      if(!reg) return;
      reg.getNotifications({ tag: id }).then(list=>{
        list.forEach(n => n.close());
      }).catch(()=>{});
    }).catch(()=>{});
  }

  const msgRef=dbRef(db,"chats/"+id+"/messages");
  currentListenerRef=msgRef;
  onChildAdded(msgRef,s=>renderMessage(s.val()));
}

// --- RENDER MESSAGE ---
function renderMessage(m){
  const div=document.createElement("div");
  div.classList.add("msg",m.sender===currentUser.uid?"me":"them");

  let senderLabel="";
  if(currentChatIsGroup && m.sender!==currentUser.uid){
    const uname=chatMembers[m.sender]||"Unknown";
    senderLabel=`<div class="sender">${uname}</div>`;
  }

  let contentHTML = "";
  
  // Standard text message (with link detection)
  const linkedText = m.text.replace(
      /(https?:\/\/[^\s]+)/g,
      '<a href="$1" target="_blank" style="color: inherit;">$1</a>'
  );
  contentHTML = linkedText;


  div.innerHTML=`
    ${senderLabel}
    ${m.replyTo?`<div style="font-size:0.85rem;color:#bbb;border-left:3px solid #007bff;padding-left:6px;margin-bottom:3px;opacity:0.8;">${m.replyTo.slice(0, 40)}...</div>`:""}
    ${contentHTML}
    <div class="timestamp">${new Date(m.time).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</div>
  `;
  messagesDiv.append(div);
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // --- SWIPE TO REPLY LOGIC (CLICK for Desktop) ---
  let startX = 0;
  let isDragging = false;
  const messageTextSnippet = m.text ? m.text.slice(0, 50) + '...' : "Message";

  div.addEventListener("touchstart", e => {
    if (e.touches.length === 1) {
      startX = e.touches[0].clientX;
      isDragging = false;
    }
  });
  
  div.addEventListener("touchmove", e => {
    if (!startX) return;
    const diff = e.touches[0].clientX - startX;
    
    if (diff > 70) {
      isDragging = true;
    }
  });

  div.addEventListener("touchend", () => {
    if (isDragging) {
      showReplyBar(messageTextSnippet); 
      isDragging = false;
    }
    startX = 0;
  });
  
  div.addEventListener("click", (e) => {
      // Allow link clicking, but use other clicks for reply
      if (e.target.tagName !== 'A') { 
          showReplyBar(messageTextSnippet);
      }
  });
  // --- END SWIPE TO REPLY LOGIC ---
}

function showReplyBar(text){
  replyTo=text;
  replyBar.style.display="flex";
  replyText.textContent="Replying to: "+text.slice(0,40);
}

cancelReplyBtn.onclick=()=>{
  replyTo=null;
  replyBar.style.display="none";
};

messageInput.addEventListener('input', startTyping);
messageInput.onkeydown = () => { startTyping(); }; 

// --- SHARED CHAT LIST UPDATE LOGIC ---
async function updateChatList(messageTime, messageSnippet) {
    const chatSnap = await get(dbRef(db, "chats/" + currentChatId));
    const chat = chatSnap.val();
    let memberUids = [];
    if (chat.members) {
        memberUids = Array.isArray(chat.members) ? chat.members : Object.keys(chat.members);
    }

    const userChatUpdates = {};
    memberUids.forEach(uid => {
        if (uid !== currentUser.uid) {
            userChatUpdates[`/userChats/${uid}/${currentChatId}/unread`] = true;
        }
        userChatUpdates[`/userChats/${uid}/${currentChatId}/lastMessageTime`] = messageTime;
        userChatUpdates[`/userChats/${uid}/${currentChatId}/lastMessageText`] = messageSnippet;
    });

    await update(dbRef(db), userChatUpdates);
}


// --- SEND TEXT BUTTON ---
document.getElementById("sendBtn").onclick=async()=>{
  const text=messageInput.value.trim();
  if(!text||!currentChatId) return;
  
  stopTyping();
  
  const messageTime = Date.now(); 
  
  await push(dbRef(db,"chats/"+currentChatId+"/messages"),{
    sender:currentUser.uid,
    text,
    replyTo,
    time: messageTime 
  });
  
  // Update lastMessageTime and lastMessageText for ALL chat members
  const messageSnippet = text.length > 50 ? text.slice(0, 50) + '...' : text;
  await updateChatList(messageTime, messageSnippet);
  
  messageInput.value="";
  replyTo=null;
  replyBar.style.display="none";
  
  loadChats(); 
};

// --- FIX: Ensure back button logic is wrapped in an event handler function ---
document.getElementById("backBtn").onclick=()=>{
  stopTyping();
  
  currentChatId=null;
  if(currentListenerRef){off(currentListenerRef); currentListenerRef=null;}
  // CRITICAL CLEANUP: Turn off the typing listener when leaving the chat
  if(currentTypingListener){off(currentTypingListener); currentTypingListener=null;}
  
  // Hide settings elements
  settingsBtn.style.display = 'none'; 
  groupSettingsMenu.style.display = 'none';

  loadChats(); 
  show(chatListScreen);
};

document.getElementById("logoutBtn").onclick=async()=>{
  if(currentChatId) stopTyping();
  
  await goOffline(); 
  await signOut(auth);
  currentUser=null;
  show(loginScreen);
};

// --- HELPER FUNCTION TO FIND USER BY USERNAME ---
async function findUserByUsername(username) {
  const usersRef = dbRef(db, 'users');
  const snap = await get(usersRef);
  
  if (!snap.exists()) return null;
  
  const users = snap.val();
  const searchUsername = username.toLowerCase(); 

  let result = null;
  
  for (const uid in users) {
    if (users[uid].username && users[uid].username.toLowerCase() === searchUsername) {
      result = { uid: uid, ...users[uid] };
      break; 
    }
  }
  return result;
}

// --- DM/GROUP LOGIC ---
document.getElementById("newDmBtn").onclick=async()=>{
  const username=prompt("Enter the username of the person you want to chat with:");
  if(!username) return;

  const user = await findUserByUsername(username);

  if (!user) {
    return alert(`User with username "${username}" not found.`);
  }
  
  if (user.uid === currentUser.uid) {
    return alert("You can't start a DM with yourself.");
  }
  
  const otherUid = user.uid;
  const otherUsername = user.username;

  try {
    // 1. Check if a DM with this user already exists in userChats
    const userChatsSnap = await get(dbRef(db, `userChats/${currentUser.uid}`));
    let existingChatId = null;

    if (userChatsSnap.exists()) {
        userChatsSnap.forEach(chatChild => {
            const chatData = chatChild.val();
            // Checking both otherUid and that it's a DM (isGroup: false)
            if (chatData.otherUid === otherUid && chatData.isGroup === false) {
                existingChatId = chatChild.key;
            }
        });
    }

    if (existingChatId) {
        // Chat exists, navigate to it
        show(chatListScreen);
        await loadChats();
        openChat(existingChatId, otherUsername);
        return;
    }

    // 2. DM does not exist, create it 
    const refNew = push(dbRef(db, "chats"));
    const newMembersMap = { [currentUser.uid]: true, [otherUid]: true };
    const creationTime = Date.now(); 
    
    await set(refNew, {
      name: otherUsername, 
      isGroup: false,
      members: newMembersMap
    });
    
    const currentUserProfileSnap = await get(dbRef(db, "users/" + currentUser.uid));
    const currentUsername = currentUserProfileSnap.val() ? currentUserProfileSnap.val().username : "You";

    await update(dbRef(db), {
      // Current User's side (You)
      [`/userChats/${currentUser.uid}/${refNew.key}`]: { 
          name: otherUsername, 
          isGroup: false,
          lastMessageTime: creationTime,
          otherUid: otherUid,
          lastMessageText: "DM created"
      }, 
      // Other User's side
      [`/userChats/${otherUid}/${refNew.key}`]: { 
          name: currentUsername, 
          isGroup: false,
          lastMessageTime: creationTime,
          otherUid: currentUser.uid,
          lastMessageText: "DM created"
      } 
    });

    // 3. Navigate to the new chat
    show(chatListScreen);
    await loadChats();
    openChat(refNew.key, otherUsername);

  } catch (e) {
    alert("Error creating DM: " + e.message);
  }
};


document.getElementById("groupBtn").onclick=async()=>{
  const name=prompt("Group name:");
  if(!name)return;
  const input=prompt("Enter usernames (comma-separated):");
  const usernames=input?input.split(",").map(u=>u.trim()):[];
  if (usernames.length === 0) return alert("Group must have members.");

  const memberIds=[currentUser.uid];
  
  for (const uname of usernames) {
    const user = await findUserByUsername(uname);
    if (user) {
      if (user.uid !== currentUser.uid && !memberIds.includes(user.uid)) {
        memberIds.push(user.uid);
      }
    } else {
      console.warn(`User "${uname}" not found. Skipping.`);
    }
  }
  
  if (memberIds.length < 2) return alert("Could not find any other valid users to add.");

  const newMembersMap = memberIds.reduce((map, uid) => {
      map[uid] = true;
      return map;
  }, {});

  const refNew=push(dbRef(db,"chats"));
  await set(refNew,{
    name,
    isGroup:true,
    members:newMembersMap
  });
  
  const userChatUpdates = {};
  const creationTime = Date.now(); 
  memberIds.forEach(uid => {
    userChatUpdates[`/userChats/${uid}/${refNew.key}`] = { 
        name: name, 
        isGroup: true,
        lastMessageTime: creationTime,
        lastMessageText: "Group created"
    };
  });
  await update(dbRef(db), userChatUpdates);

  loadChats();
};

// --- GROUP SETTINGS LOGIC ---

// Toggle visibility of the settings menu
settingsBtn.onclick = () => {
    if (currentChatIsGroup) {
        groupSettingsMenu.style.display = groupSettingsMenu.style.display === 'flex' ? 'none' : 'flex';
        groupSettingsMenu.style.flexDirection = 'column';
    }
};

// Handle click outside the menu to close it
document.addEventListener('click', (e) => {
    if (groupSettingsMenu.style.display === 'flex' && !settingsBtn.contains(e.target) && !groupSettingsMenu.contains(e.target)) {
        groupSettingsMenu.style.display = 'none';
    }
});


// FIX: Ensure rename button logic is correctly linked
document.getElementById('renameGroupBtn').onclick = async () => {
    if (!currentChatId || !currentChatIsGroup) return;
    groupSettingsMenu.style.display = 'none';

    const newName = prompt("Enter new group name:");
    if (!newName || newName.trim() === '') return;

    try {
        // 1. Update the chat name in the main /chats node
        await update(dbRef(db, `chats/${currentChatId}`), { name: newName });

        // 2. Get current members to update their userChats node
        const chatSnap = await get(dbRef(db, `chats/${currentChatId}`));
        const chat = chatSnap.val();
        let memberUids = Object.keys(chat.members || {});
        
        const userChatUpdates = {};
        memberUids.forEach(uid => {
            userChatUpdates[`/userChats/${uid}/${currentChatId}/name`] = newName;
        });

        await update(dbRef(db), userChatUpdates);
        
        alert(`Group renamed to "${newName}" successfully!`);
        openChat(currentChatId, newName); // Re-open chat to update header
        loadChats(); // Update chat list

    } catch (error) {
        alert("Error renaming group: " + error.message);
    }
};

// FIX: Ensure add members button logic is correctly linked
document.getElementById('addMembersBtn').onclick = async () => {
    if (!currentChatId || !currentChatIsGroup) return;
    groupSettingsMenu.style.display = 'none';

    const input = prompt("Enter usernames to add (comma-separated):");
    const usernames = input ? input.split(",").map(u => u.trim()).filter(u => u !== '') : [];
    if (usernames.length === 0) return;

    try {
        const chatSnap = await get(dbRef(db, `chats/${currentChatId}`));
        const chat = chatSnap.val();
        let currentMembersMap = chat.members || {};
        let membersUpdated = false;

        const userChatUpdates = {};
        const newMembers = [];
        const groupName = chat.name || "Group";

        for (const uname of usernames) {
            const user = await findUserByUsername(uname);
            if (user) {
                if (!currentMembersMap[user.uid]) {
                    currentMembersMap[user.uid] = true;
                    newMembers.push(user.username);
                    membersUpdated = true;

                    // Add to their userChats node
                    userChatUpdates[`/userChats/${user.uid}/${currentChatId}`] = { 
                        name: groupName, 
                        isGroup: true,
                        lastMessageTime: Date.now(),
                        lastMessageText: `You were added to the group by ${currentUser.displayName || "a member"}`
                    };
                }
            } else {
                console.warn(`User "${uname}" not found. Skipping.`);
            }
        }

        if (membersUpdated) {
            // 1. Update the main /chats members list
            await update(dbRef(db, `chats/${currentChatId}`), { members: currentMembersMap });

            // 2. Update all affected userChats nodes
            await update(dbRef(db), userChatUpdates);
            
            alert(`Added new members: ${newMembers.join(', ')}`);
            openChat(currentChatId, groupName); // Re-open chat
            loadChats(); // Update chat list
        } else {
            alert("No new valid members were added.");
        }

    } catch (error) {
        alert("Error adding members: " + error.message);
    }
};


// --- LISTEN FOR UNREAD ---
function listenForUnread(){
  const userChatsRef = dbRef(db,"userChats/"+currentUser.uid);
  onValue(userChatsRef,snap=>{
    if(!snap.exists()) return;
    snap.forEach(child=>{
      const chatId=child.key;
      const data=child.val();
      const chatDiv=[...chatList.children].find(d=>d.dataset.id===chatId);
      if(chatDiv){
        if(data.unread) chatDiv.classList.add("unread");
        else chatDiv.classList.remove("unread");
      }
    });
  });

  onValue(dbRef(db,"chats"), snap => {
    if(!snap.exists()) return;
    snap.forEach(chatSnap => {
      const chatId = chatSnap.key;
      const chat = chatSnap.val();
      
      let isMember = false;
      if (chat.members) {
        if (Array.isArray(chat.members)) {
          isMember = chat.members.includes(currentUser.uid);
        } else if (typeof chat.members === 'object') {
          isMember = Object.keys(chat.members).includes(currentUser.uid);
        }
      }

      if(!isMember) return;

      if(activeMessageListeners.has(chatId)) return;
      activeMessageListeners.add(chatId);

      const msgRef = dbRef(db,"chats/"+chatId+"/messages");
      onChildAdded(msgRef, msgSnap => {
        const m = msgSnap.val();

        if(!m || !m.sender || m.sender === currentUser.uid) {
           return;
        }
        
        const messageSnippet = m.text.length > 50 ? m.text.slice(0, 50) + '...' : m.text;

        // Update last message time and text
        update(dbRef(db, `/userChats/${currentUser.uid}/${chatId}`), {
             lastMessageTime: m.time,
             lastMessageText: messageSnippet
        }).catch(()=>{});

        get(dbRef(db,"userChats/"+currentUser.uid+"/"+chatId)).then(userChatSnap=>{
          const data = userChatSnap.val() || {};
          const lastRead = data.lastRead || 0;

          if(m.time > lastRead && currentChatId !== chatId){
            update(dbRef(db,"userChats/"+currentUser.uid+"/"+chatId),{ unread:true });
            
            loadChats(); 

            const chatDiv = [...chatList.children].find(d => d.dataset.id === chatId);
            const title = chatDiv ? chatDiv.querySelector('div:first-child').firstChild.textContent.trim() : "New message";
            showNotification(title, m.text || "New Message", chatId);

          }
        }).catch(()=>{});
      });
    });
  });
}

// service worker registration and permission
if("serviceWorker" in navigator){
  navigator.serviceWorker.register("sw.js").then(()=> {
    if(Notification.permission !== "granted" && Notification.permission !== "denied"){
      Notification.requestPermission();
    }
  }).catch(()=>{});
}

function showNotification(title, body, tag){
  if(!("Notification" in window)) return;
  if(Notification.permission === "granted" && "serviceWorker" in navigator){
    navigator.serviceWorker.ready.then(reg => {
      try {
        reg.showNotification(title, {
          body,
          icon: "https://cdn-icons-png.flaticon.com/512/906/906349.png",
          tag
        });
      } catch(e){}
    }).catch(()=>{});
  } else if(Notification.permission !== "denied"){
    Notification.requestPermission().then(p => {
      if(p === "granted"){
        try { new Notification(title, { body, icon: "https://cdn-icons-png.flaticon.com/512/906/906349.png", tag }); } catch(e) {}
      }
    });
  }
}
</script>
</body>
</html>
