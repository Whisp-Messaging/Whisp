<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Whisp</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
  /* --- GLOBAL & BASE STYLES --- */
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    /* Use a cleaner, slightly softer dark mode palette */
    background: #121212; /* Deep background for contrast */
    color: #e0e0e0;      
    font-family: 'Roboto', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  main {
    height: 100%; /* Default to full height */
    width: 100%; /* Default to full width */
    display: flex;
    flex-direction: column;
    background: #1e1e1e; /* Main app background - slightly lighter than body */
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    margin: 0 auto;
  }

  .screen { 
    display: none; 
    flex-direction: column; 
    height: 100%; 
    transition: opacity 0.3s ease;
  }
  .screen.active { 
    display: flex; 
  }
  
  /* --- 1. LOGIN SCREEN --- */
  #loginScreen {
    justify-content: center;
    align-items: center;
    background: #1e1e1e;
  }
  #loginScreen h2 { 
    font-size: 2.2rem; 
    margin-bottom: 25px; 
    color: #007bff; 
    font-weight: 700;
  }
  #loginScreen input {
    display: block;
    width: 90%;
    max-width: 350px; 
    margin: 15px auto;
    padding: 14px;
    border-radius: 8px; 
    border: none;
    background: #333333;
    color: #ffffff;
    font-size: 1rem;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }
  #loginBtn {
    background: #007bff;
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    font-size: 1.1rem;
    transition: background 0.3s, transform 0.1s;
    margin-top: 20px;
  }
  #loginBtn:hover { background: #0056b3; }
  #loginBtn:active { transform: scale(0.98); }

  /* --- 2. CHAT LIST SCREEN --- */
  #chatListScreen { background: #1e1e1e; flex: 1; }
  #chatListHeader {
    background: #121212;
    color: white;
    padding: 16px 20px;
    font-weight: 700;
    border-bottom: 1px solid #333333;
    font-size: 1.3rem;
  }
  #chatList { flex: 1; overflow-y: auto; padding-bottom: 70px; }
  .chatItem {
    padding: 15px 20px; 
    border-bottom: 1px solid #333333;
    cursor: pointer;
    transition: background 0.2s;
    font-size: 1.05rem; 
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .chatItem:hover { background: #252526; }
  .chatItem.unread {
    font-weight: 500;
    background: #2a3a4a; 
  }
  .chatItem .lastMessage {
      font-size: 0.85rem;
      color: #999;
      max-width: 90%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      margin-top: 2px;
  }

  /* Bottom Menu */
  #bottomMenu {
    display: flex;
    justify-content: space-around; 
    align-items: center;
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: #121212;
    padding: 10px 0; 
    border-top: 1px solid #333333;
    z-index: 10;
  }
  #bottomMenu button {
    background: #007bff;
    color: white;
    border: none;
    padding: 8px 16px; 
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.3s;
  }
  #bottomMenu button:hover { background: #0056b3; }
  
  /* --- 3. CHAT SCREEN --- */
  #chatScreen { background: #121212; position: relative; } /* Added relative for menu positioning */
  #chatHeader {
    background: #1e1e1e;
    color: white;
    padding: 10px 10px; 
    display: flex;
    flex-direction: column; 
    border-bottom: 1px solid #333333;
  }
  #chatHeader button { 
    background: none; 
    border: none; 
    color: white; 
    font-size: 1.4rem; 
    cursor: pointer; 
    padding: 0 5px; 
    transition: color 0.2s;
  }
  #chatHeader button:hover { color: #007bff; }
  
  #chatHeader div.main-row { 
    width: 100%; 
    display: flex; 
    align-items: center; 
    justify-content: space-between; /* To push settings button to the right */
  }
  #chatNameContainer { 
    display: flex; 
    flex-direction: column; 
    align-items: flex-start; 
    flex-grow: 1;
    margin-left: 10px;
  }
  #chatName { 
    font-size: 1.15rem; 
    font-weight: 600; 
  }

  /* --- Group Settings Menu Style --- */
  #settingsBtn {
    margin-left: 10px;
    font-size: 1.2rem !important;
    display: none; /* Hidden by default */
  }

  #groupSettingsMenu {
    position: absolute;
    top: 60px; /* Adjust based on header height */
    right: 15px;
    background: #333;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    z-index: 20;
    overflow: hidden;
    display: none;
  }
  #groupSettingsMenu button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 12px 20px;
    background: none;
    border: none;
    color: #e0e0e0;
    cursor: pointer;
    font-size: 1rem;
    transition: background 0.2s;
  }
  #groupSettingsMenu button:hover {
    background: #444;
  }
  /* --- End Group Settings Menu Style --- */

  /* Status Styles */
  #chatStatus { 
    font-size: 0.7rem; 
    color: #999; 
    height: 14px; 
    font-weight: 400;
  }
  #chatStatus.online { 
    color: #00ff8c; 
    font-weight: 500;
  } 

  /* Typing Indicator Style */
  #typingIndicator { 
    font-size: 0.75rem; 
    color: #00aaff; 
    font-style: italic;
    height: 16px; 
    text-align: left;
    padding: 3px 0 0 40px; 
    width: 100%;
    overflow: hidden;
  }
  
  #messages { 
    flex: 1; 
    overflow-y: auto; 
    padding: 10px 15px; 
    display: flex; 
    flex-direction: column; 
    gap: 5px;
  }
  .msg {
    max-width: 80%; 
    margin-bottom: 5px;
    padding: 10px 14px; 
    border-radius: 18px; 
    position: relative;
    word-wrap: break-word;
    line-height: 1.4;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
  .me {
    align-self: flex-end;
    background: #007bff; 
    color: white;
    border-bottom-right-radius: 4px;
  }
  .them {
    align-self: flex-start;
    background: #333333; 
    color: #e0e0e0;
    border-bottom-left-radius: 4px;
  }
  .timestamp { 
    font-size: 0.65rem; 
    color: rgba(255,255,255,0.6); 
    text-align: right; 
    margin-top: 4px; 
    display: flex;
    align-items: center;
    justify-content: flex-end;
  }
  .them .timestamp {
    color: rgba(224,224,224,0.6);
  }
  .sender { 
    font-size: 0.8rem; 
    color: #00c7ff; 
    font-weight: 600; 
    margin-bottom: 3px; 
  }
  .msg a { color: inherit; text-decoration: underline; }

  /* --- NEW STYLES FOR READ/EDIT --- */
  .read-status-icon {
    font-size: 0.8rem; /* Slightly larger checkmark */
    margin-left: 5px;
    display: inline-block;
    opacity: 0.9;
    /* Default: Sent/Delivered (Gray) */
    color: #ddd; 
  }

  .read-status-icon.read {
    /* WhatsApp Blue for Read */
    color: #00bfff; 
  }

  .edit-indicator {
    font-size: 0.65rem;
    font-style: italic;
    margin-right: 5px;
    color: rgba(255,255,255,0.7);
  }

  /* --- MEDIA MESSAGE STYLES --- */
  .media-container {
    padding: 0;
    overflow: hidden;
    display: inline-block;
    max-width: 100%; /* Important for responsiveness */
    border-radius: 10px;
  }
  .media-container img {
    display: block;
    max-width: 250px; 
    max-height: 300px;
    width: auto;
    height: auto;
    border-radius: 10px;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .media-container img:hover {
    opacity: 0.9;
  }
  /* Remove default padding from image-only messages */
  .msg.media-only {
    padding: 0;
    background: transparent;
    box-shadow: none;
  }
  .msg.media-only.me {
    align-self: flex-end;
  }
  .msg.media-only.them {
    align-self: flex-start;
  }
  .msg.media-only .timestamp {
    /* Position timestamp slightly better for image messages */
    margin: 5px 10px 0 0;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
  }
  /* --- END MEDIA MESSAGE STYLES --- */


  /* Reply Bar */
  #replyBar {
    display: none;
    background: #2a2a2a;
    padding: 8px 15px; 
    border-left: 4px solid #007bff;
    font-size: 0.9rem;
    align-items: center;
    display: flex;
    justify-content: space-between;
  }
  #replyText { flex: 1; color: #ccc; }
  #cancelReply { 
    background: none; 
    border: none; 
    color: #007bff; 
    font-weight: bold; 
    cursor: pointer; 
    margin-left: 10px; 
    font-size: 1.2rem;
  }

  /* --- INPUT BAR --- */
  #inputBar {
    display: flex;
    align-items: flex-end; 
    background: #1e1e1e;
    padding: 8px 15px; 
    border-top: 1px solid #333333;
  }
  #mediaBtn {
    background: none; 
    color: #007bff; 
    border: none; 
    padding: 0 8px; 
    margin-bottom: 2px;
    cursor: pointer;
    font-size: 1.4rem;
    line-height: 1; 
    transition: color 0.2s;
  }
  #mediaBtn:hover {
    color: #0056b3;
  }
  #message {
    flex: 1;
    padding: 10px 16px; 
    border-radius: 20px;
    border: none;
    background: #333333;
    color: #fff;
    outline: none;
    font-size: 1rem;
    resize: none;
    max-height: 80px; 
    overflow-y: auto;
    margin: 0 8px; /* Add margin around textarea */
  }
  #sendBtn {
    background: #007bff;
    color: white;
    border: none;
    border-radius: 50%;
    width: 44px; 
    height: 44px; 
    margin-left: 0; 
    margin-right: -4px;
    font-size: 1.4rem;
    cursor: pointer;
    transition: background 0.3s, transform 0.1s;
    margin-bottom: 2px;
  }
  #sendBtn:hover { background: #0056b3; }
  #sendBtn:active { transform: scale(0.95); }
  
  /* --- 4. PROFILE SCREEN --- */
  #profileScreen { background: #1e1e1e; flex: 1; }
  #profileHeader {
    background: #121212;
    color: white;
    padding: 16px 20px;
    display: flex;
    align-items: center;
    border-bottom: 1px solid #333333;
  }
  #profileHeader button { 
    background: none; 
    border: none; 
    color: white; 
    font-size: 1.4rem; 
    cursor: pointer; 
    padding: 0 10px; 
    transition: color 0.2s;
  }
  #profileHeader button:hover { color: #007bff; }

  #profileContent input {
      display: block;
      width: 90%;
      max-width: 400px;
      margin: 8px 0 15px 0;
      padding: 10px;
      border-radius: 6px;
      border: none;
      background: #333333;
      color: #ffffff;
      font-size: 1rem;
  }

  #profileContent button {
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.3s;
  }

  /* --- 5. ADMIN SCREEN --- */
  #adminScreen { background: #1e1e1e; flex: 1; }
  #adminHeader {
    background: #121212;
    color: white;
    padding: 16px 20px;
    display: flex;
    align-items: center;
    border-bottom: 1px solid #333333;
  }
  #adminHeader button { 
    background: none; 
    border: none; 
    color: white; 
    font-size: 1.4rem; 
    cursor: pointer; 
    padding: 0 10px; 
    transition: color 0.2s;
  }
  #adminHeader button:hover { color: #007bff; }

  #adminSearch {
    display: flex;
    padding: 20px;
    border-bottom: 1px solid #333;
  }
  #adminSearch input {
      flex: 1;
      padding: 10px;
      border-radius: 6px;
      border: none;
      background: #333;
      color: #fff;
      margin-right: 10px;
  }
  #adminSearch button {
      background: #00aaff;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
  }
  #adminResults {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
  }
  #userInfo {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #333;
  }
  #userInfo strong {
      color: #007bff;
      font-weight: 500;
  }
  .audit-item {
      padding: 10px;
      border: 1px solid #333;
      border-radius: 6px;
      margin-top: 10px;
      background: #2a2a2a;
      font-size: 0.9rem;
  }
  .audit-item strong {
      display: block;
      color: #00ff8c;
      margin-bottom: 5px;
  }


  /* --- MEDIA QUERY: DESKTOP/TABLET OPTIMIZATION --- */
  @media (min-width: 700px) {
    /* Main container is now full screen on desktop/tablet */
    main { 
        max-width: 100%; 
        height: 100vh; 
        margin: 0; 
        border-radius: 0; 
    }
    /* Fixed bottom menu now correctly stays at the bottom of the full screen */
    #bottomMenu { 
        position: fixed; 
        padding: 10px 0;
        left: 0;
        transform: none;
        max-width: 100%;
    }
  }

  /* --- MEDIA QUERY: MOBILE OPTIMIZATION (re-apply sleek size) --- */
  @media (max-width: 699px) {
    main {
        max-width: 600px; 
        height: 100%;
    }
    #bottomMenu {
        /* On mobile, ensure the menu aligns with the centered main container */
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        max-width: 600px; 
    }
  }
</style>
</head>
<body>
<main>
  <section id="loginScreen" class="screen active">
    <div>
      <h2>Welcome to Whisp 💬</h2>
      <input id="email" placeholder="Email" />
      <input id="password" type="password" placeholder="Password" />
      <input id="username" placeholder="Username (for signup)" />
      <button id="loginBtn">Login / Register</button>
    </div>
  </section>

  <section id="chatListScreen" class="screen">
    <div id="chatListHeader">Whisp Chats</div>
    <div id="chatList"></div>
    <div id="bottomMenu">
      <button id="newDmBtn">New DM</button> 
      <button id="groupBtn">New Group</button>
      <button id="profileBtn">Profile</button>
      <button id="adminBtn" style="display: none; background: #ff7f00;">Admin Panel</button> <button id="logoutBtn">Logout</button>
    </div>
  </section>
  
  <section id="chatScreen" class="screen">
    <div id="chatHeader">
      <div class="main-row">
        <button id="backBtn">←</button>
        <div id="chatNameContainer">
            <span id="chatName">Chat</span>
            <span id="chatStatus"></span>
        </div>
        <button id="settingsBtn" style="display: none;">⋮</button> </div>
      <div id="typingIndicator"></div>
    </div>
    
    <div id="groupSettingsMenu">
        <button id="renameGroupBtn">Rename Group</button>
        <button id="addMembersBtn">Add Members</button>
    </div>
    <div id="messages"></div>
    <div id="replyBar">
      <span id="replyText"></span>
      <button id="cancelReply">✖</button>
    </div>
    <div id="inputBar">
      <button id="mediaBtn" title="Send Image URL">&#128206;</button> 
      <textarea id="message" placeholder="Type a message..."></textarea>
      <button id="sendBtn">➤</button>
    </div>
  </section>

  <section id="profileScreen" class="screen">
    <div id="profileHeader">
      <button id="profileBackBtn">←</button>
      <span style="font-size: 1.15rem; font-weight: 600;">Account Settings</span>
    </div>
    <div id="profileContent" style="padding: 20px;">
      <h3>User Profile</h3>
      <p>Username: <strong id="currentUsernameDisplay"></strong> (Cannot be changed)</p>
      
      <label for="firstName">First Name:</label>
      <input id="firstName" placeholder="First Name" />
      
      <label for="lastName">Last Name:</label>
      <input id="lastName" placeholder="Last Name" />
      
      <button id="saveNameBtn" style="margin-top: 15px; background: #007bff;">Save Name</button>
      
      <hr style="border: none; border-top: 1px solid #333; margin: 30px 0;">

      <h3>Change Password</h3>
      <input id="newPassword" type="password" placeholder="New Password (min 6 chars)" />
      <input id="confirmPassword" type="password" placeholder="Confirm New Password" />
      <button id="changePasswordBtn" style="margin-top: 15px; background: #ff7f00;">Change Password</button>
      
    </div>
  </section>
  
  <section id="adminScreen" class="screen">
    <div id="adminHeader">
        <button id="adminBackBtn">←</button>
        <span style="font-size: 1.15rem; font-weight: 600;">Admin Panel</span>
    </div>
    <div id="adminSearch">
        <input id="adminSearchInput" placeholder="Enter username to audit..." />
        <button id="adminSearchBtn">Search</button>
    </div>
    <div id="adminResults">
        <p>Search for a user to manage their account and view audit logs.</p>
        <div id="userInfo" style="display: none;">
            <h4>User Details:</h4>
            <p><strong>UID:</strong> <span id="adminUid"></span></p>
            <p><strong>Username:</strong> <span id="adminUsername"></span></p>
            <p><strong>Email:</strong> <span id="adminEmail"></span></p>
            <p><strong>Full Name:</strong> <span id="adminFullName"></span></p>
            <p><strong>Last Activity:</strong> <span id="adminLastSeen"></span></p>
            <button id="deleteAccountBtn" style="background: #dc3545; color: white; border: none; padding: 8px 15px; border-radius: 6px; margin-top: 15px;">DELETE ACCOUNT</button>
            
            <h4 style="margin-top: 25px;">Chat Audit Log (Metadata Only):</h4>
            <div id="adminChatLog"></div>
        </div>
    </div>
  </section>

</main>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, updatePassword, deleteUser } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import { getDatabase, ref, set, push, get, onChildAdded, onValue, off, update, remove, onDisconnect, query, limitToLast, orderByChild, startAt, endAt, equalTo } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

// !!! 🚨 IMPORTANT: REPLACE WITH YOUR OWN FIREBASE CONFIGURATION !!!
const firebaseConfig = {
  apiKey: "AIzaSyCEdtncZpDgOSnULIjopee7GKh9h9hveKk",
  authDomain: "messagingapp-7ede5.firebaseapp.com",
  databaseURL: "https://messagingapp-7ede5-default-rtdb.firebaseio.com",
  projectId: "messagingapp-7ede5",
  messagingSenderId: "221896974865",
  appId: "1:221896974865:web:3faca4885e48ee656907b0"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

const loginScreen=document.getElementById("loginScreen"),
      chatListScreen=document.getElementById("chatListScreen"),
      chatScreen=document.getElementById("chatScreen"),
      profileScreen=document.getElementById("profileScreen"),
      adminScreen=document.getElementById("adminScreen"), 
      adminBtn=document.getElementById("adminBtn"), 
      chatList=document.getElementById("chatList"),
      messagesDiv=document.getElementById("messages"),
      replyBar=document.getElementById("replyBar"),
      replyText=document.getElementById("replyText"),
      cancelReplyBtn=document.getElementById("cancelReply"),
      messageInput=document.getElementById("message"),
      mediaBtn = document.getElementById("mediaBtn"),
      typingIndicator=document.getElementById("typingIndicator"),
      chatStatus=document.getElementById("chatStatus"),
      settingsBtn = document.getElementById("settingsBtn"), 
      groupSettingsMenu = document.getElementById("groupSettingsMenu"); 

let currentUser=null, currentChatId=null, replyTo=null, currentListenerRef=null, otherUserUid=null; 
let currentChatIsGroup=false, chatMembers={};
let typingTimer=null, typingStatusRef=null, currentTypingListener = null, currentPresenceListener = null; 
let isAdmin = false; 
let activeMessageListeners = new Set();
let currentTargetUid = null; 
let lastRegisteredUsername = null; 
let currentMessageUpdateListener = null; // NEW Listener for seen/edited updates

const EDIT_WINDOW_MS = 10 * 60 * 1000; // 10 minutes in milliseconds

const show=(s)=>{[loginScreen,chatListScreen,chatScreen,profileScreen, adminScreen].forEach(e=>e.classList.remove("active"));s.classList.add("active");}; 

// --- USER DISPLAY NAME HELPER ---
async function getUserDisplayName(uid) {
    const uSnap = await get(ref(db, "users/" + uid));
    if (uSnap.exists()) {
        const userData = uSnap.val();
        
        if (userData.fullName) return userData.fullName;
        if (userData.displayName) return userData.displayName;
        if (userData.username) return userData.username; 
        if (userData.email) return userData.email.split('@')[0];

        return "Unknown User";
    }
    return "Deleted User";
}

// --- PRESENCE HANDLERS ---
function formatLastSeen(timestamp) {
    if (!timestamp) return "N/A (Never logged in)";
    if (timestamp === true) return "Online";

    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    if (diff < 60000) return "just now";
    if (diff < 3600000) return `Last seen ${Math.floor(diff / 60000)}m ago`;
    if (date.toDateString() === now.toDateString()) return `Last seen today at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (date.toDateString() === yesterday.toDateString()) return `Last seen yesterday at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    
    return `Last seen ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
}

async function goOnline() {
    if (!currentUser) return;
    const isOnlineRef = ref(db, 'presence/' + currentUser.uid);

    await set(isOnlineRef, true);
    onDisconnect(isOnlineRef).set(Date.now());
}

async function goOffline() {
    if (!currentUser) return;
    const isOnlineRef = ref(db, 'presence/' + currentUser.uid);

    onDisconnect(isOnlineRef).cancel();
    await set(isOnlineRef, Date.now());
}

// --- LOGIN/REGISTER HANDLER ---
document.getElementById("loginBtn").onclick = async () => {
  const emailVal = document.getElementById("email").value.trim();
  const passwordVal = document.getElementById("password").value.trim();
  const usernameVal = document.getElementById("username").value.trim();
  if(!emailVal || !passwordVal) return alert("Enter credentials.");
  
  try {
    let cred;
    try {
      // 1. Attempt login 
      cred = await signInWithEmailAndPassword(auth, emailVal, passwordVal);
      lastRegisteredUsername = null; 
      return; 
    } catch (e) {
      // 2. If login fails, attempt registration
      
      if(!usernameVal) {
        return alert("Login failed. If you are registering, you MUST provide a username.");
      }
      
      const finalUsername = usernameVal;
      const normalizedUsername = finalUsername.toLowerCase();

      // --- UNIQUENESS CHECK ---
      const usersRef = ref(db, 'users');
      const usersQuery = query(usersRef, orderByChild('username'), equalTo(normalizedUsername));
      const snap = await get(usersQuery);
      
      if (snap.exists()) {
        return alert(`The username "${finalUsername}" is already taken. Please choose another.`);
      }
      // --- END UNIQUENESS CHECK ---
      
      // 3. Create user
      cred = await createUserWithEmailAndPassword(auth, emailVal, passwordVal);
      
      const uid = cred.user.uid;
      lastRegisteredUsername = normalizedUsername;
      
      // 4. Set user profile and add to /usernames for quick lookup
      await set(ref(db, "users/" + uid), { 
        username: normalizedUsername, 
        displayName: finalUsername, 
        email: emailVal 
      });
      await set(ref(db, "usernames/" + normalizedUsername), uid); 
      
      lastRegisteredUsername = null;
    }
  } catch (e) {
    alert(e.message);
  }
};

// --- AUTH STATE CHANGED ---
onAuthStateChanged(auth, async user => {
  if(user){
    currentUser=user;
    activeMessageListeners = new Set();
    
    const uSnap = await get(ref(db, "users/" + user.uid));
    let currentUsername = "";
    
    if (uSnap.exists()) {
        const userData = uSnap.val();
        currentUsername = userData.username || ""; 
        
        if (!userData.username) {
             const defaultUsername = user.email.split('@')[0].toLowerCase();
             currentUsername = defaultUsername;
             await update(ref(db, "users/" + user.uid), {
                 username: defaultUsername 
             });
        }
        
    } else {
        const defaultUsername = user.email.split('@')[0].toLowerCase();
        let finalUsernameForDb = lastRegisteredUsername || defaultUsername;
        
        currentUsername = finalUsernameForDb;
        
        await set(ref(db, "users/" + user.uid), { 
             username: finalUsernameForDb, 
             email: user.email 
        });
        lastRegisteredUsername = null; 
    }

    const ADMIN_USERNAMES = ["admin", "clipscomb"]; 
    isAdmin = ADMIN_USERNAMES.includes(currentUsername);
    
    adminBtn.style.display = isAdmin ? 'block' : 'none';

    await loadChats();
    goOnline(); 
    show(chatListScreen);
    listenForUnread();
  } else {
    currentUser=null;
    isAdmin = false;
    adminBtn.style.display = 'none';
    activeMessageListeners.forEach(chatId => {
      try { off(ref(db,"chats/"+chatId+"/messages")); } catch(_) {}
    });
    activeMessageListeners.clear();
    show(loginScreen);
  }
});

// --- LOAD CHATS ---
async function loadChats(){
  chatList.innerHTML="";
  
  const userChatsSnap = await get(ref(db, `userChats/${currentUser.uid}`));
  if(!userChatsSnap.exists()) return;

  const chatPromises = [];
  userChatsSnap.forEach(chatChild => {
      const chatId = chatChild.key;
      const data = chatChild.val(); 
      
      const chatPromise = get(ref(db, `chats/${chatId}`)).then(async chatSnap => {
          if (!chatSnap.exists()) return null;
          
          const chat = chatSnap.val();
          
          let isMember = false;
          let memberUids = [];
          
          if (chat.members) {
            if (Array.isArray(chat.members)) { 
                memberUids = chat.members; 
            } else { 
                memberUids = Object.keys(chat.members); 
            }
            isMember = memberUids.includes(currentUser.uid);
          }

          if(!isMember) return null;
          
          let chatName = data.name; 
          let isDM = data.isGroup === false;
          
          if (!data.isGroup && memberUids.length === 2) {
              isDM = true;
          }
          
          let updateNeeded = false; 
          let finalOtherUid = data.otherUid;
          
          if (isDM) {
              if (!finalOtherUid) {
                  finalOtherUid = memberUids.find(uid => uid !== currentUser.uid);
                  if (finalOtherUid) {
                      updateNeeded = true; 
                  }
              }
              
              if (finalOtherUid) { 
                  const correctName = await getUserDisplayName(finalOtherUid);
                  chatName = correctName; 
                  
                  if (data.name !== correctName || !data.name) { 
                      updateNeeded = true;    
                  }
                  chatMembers[finalOtherUid] = correctName; 
              } else {
                  chatName = "DM (User Missing)";
              }
          }
          
          let lastMessageText = data.lastMessageText || "No messages yet";
          if (!data.lastMessageText) {
             const messagesQuery = query(ref(db, `chats/${chatId}/messages`), limitToLast(1));
             const msgSnap = await get(messagesQuery);
             if (msgSnap.exists()) {
                 let lastMsg = null;
                 msgSnap.forEach(child => lastMsg = child.val());
                 if (lastMsg) {
                     if (lastMsg.type === 'image') {
                         lastMessageText = `🖼️ Image: ${lastMsg.text.length > 50 ? lastMsg.text.substring(0, 50) + '...' : lastMsg.text}`;
                     } else if (lastMsg.type) {
                         lastMessageText = `📎 File: ${lastMsg.text || 'Attachment'}`;
                     } else {
                         lastMessageText = lastMsg.text; 
                     }
                 }
             }
          }

          return { 
              id: chatId, 
              name: chatName, 
              lastTime: data.lastMessageTime || 0,
              unread: data.unread,
              updateNeeded: updateNeeded,
              lastMessageText: lastMessageText,
              finalOtherUid: finalOtherUid 
          };
      });
      chatPromises.push(chatPromise);
  });

  const chatItems = (await Promise.all(chatPromises)).filter(item => item !== null);
  chatItems.sort((a, b) => b.lastTime - a.lastTime);

  const correctionPromises = [];
  chatItems.forEach(item => {
    const div = document.createElement("div");
    div.className = "chatItem";
    div.dataset.id = item.id;
    
    div.innerHTML = `
        <div>
            ${item.name}
            <div class="lastMessage">${item.lastMessageText}</div>
        </div>
    `;
    
    if(item.unread) div.classList.add("unread"); 
    div.onclick = () => openChat(item.id, item.name); 
    chatList.append(div);
    
    if (item.updateNeeded) {
        const updateData = { name: item.name };
        if (item.finalOtherUid) updateData.otherUid = item.finalOtherUid; 
        
        correctionPromises.push(
            update(ref(db, `/userChats/${currentUser.uid}/${item.id}`), updateData)
        );
    }
  });
  
  await Promise.all(correctionPromises).catch(e => console.error("Error during chat name correction:", e));
}

// --- TYPING INDICATOR HANDLERS (Unchanged) ---
function startTyping(){
    if(!currentChatId || !currentUser) return;
    if(typingTimer) clearTimeout(typingTimer);

    typingStatusRef = ref(db, "typing/" + currentChatId + "/" + currentUser.uid);
    set(typingStatusRef, Date.now()).catch(()=>{});
    typingTimer = setTimeout(stopTyping, 2000);
}

function stopTyping(){
    if(typingTimer) clearTimeout(typingTimer);
    if(typingStatusRef) remove(typingStatusRef).catch(()=>{});
    typingTimer = null;
    typingStatusRef = null;
}

// --- OPEN CHAT (UPDATED FOR READ/EDIT LISTENERS) ---
async function openChat(id,name){
  stopTyping(); 
  
  const oldChatId = currentChatId;
  const oldOtherUserUid = otherUserUid;

  if(currentListenerRef){ off(currentListenerRef); currentListenerRef=null; }
  if(currentTypingListener && oldChatId){ 
    off(ref(db, "typing/" + oldChatId), currentTypingListener); 
    currentTypingListener = null; 
  }
  if (currentPresenceListener && oldOtherUserUid) {
    off(ref(db, 'presence/' + oldOtherUserUid), currentPresenceListener);
    currentPresenceListener = null;
  }
  if (currentMessageUpdateListener && oldOtherUserUid) { // NEW: Unsubscribe from old message update listener
      off(ref(db, `userChats/${oldOtherUserUid}/${oldChatId}`), currentMessageUpdateListener);
      currentMessageUpdateListener = null;
  }
  
  // Reset/Set New Chat Context
  currentChatId=id;
  document.getElementById("chatName").textContent=name;
  messagesDiv.innerHTML="";
  typingIndicator.textContent = ""; 
  chatStatus.textContent = ""; 
  chatStatus.classList.remove("online");
  chatMembers = {}; 
  otherUserUid = null; 
  groupSettingsMenu.style.display = 'none'; 
  settingsBtn.style.display = 'none'; 

  show(chatScreen);

  const chatSnap=await get(ref(db,"chats/"+id));
  if (!chatSnap.exists()) return;
  
  const chat=chatSnap.val();
  currentChatIsGroup = chat.isGroup || false;
  
  if (currentChatIsGroup) { 
      settingsBtn.style.display = 'block';
  }

  const userChatSnap = await get(ref(db, `userChats/${currentUser.uid}/${id}`));
  const userChatData = userChatSnap.val();
  if (userChatData && userChatData.otherUid) {
      otherUserUid = userChatData.otherUid;
  }
  
  if(chat.members){
    let memberUids = Array.isArray(chat.members) ? chat.members : Object.keys(chat.members);
    
    if (!otherUserUid && !currentChatIsGroup && memberUids.length === 2) {
        otherUserUid = memberUids.find(uid => uid !== currentUser.uid);
    }

    for(const uid of memberUids){
      try {
        chatMembers[uid] = await getUserDisplayName(uid);
      } catch(e) {
        chatMembers[uid] = "Unknown";
      }
    }
  }
  
  // --- Read Receipts Listener (NEW) ---
  if (otherUserUid && !currentChatIsGroup) {
      const otherUserChatRef = ref(db, `userChats/${otherUserUid}/${id}`);
      currentMessageUpdateListener = onValue(otherUserChatRef, (snapshot) => {
          if (currentChatId !== id) return;
          const otherChatData = snapshot.val();
          if (otherChatData && otherChatData.lastRead) {
              // Trigger a status update check on all messages
              messagesDiv.querySelectorAll('.msg.me').forEach(msgDiv => {
                  const msgTime = parseInt(msgDiv.dataset.time, 10);
                  const msgId = msgDiv.dataset.id;
                  if (msgId && msgTime) {
                      updateMessageStatus(msgId, msgTime, otherChatData.lastRead, otherUserUid);
                  }
              });
          }
      });
  }
  // --- END Read Receipts Listener ---
  
  
  // ... (Presence Listener and Typing Listener remain unchanged) ...
  
  // --- Presence Listener for DM Status ---
  if (otherUserUid) {
      const presenceRef = ref(db, 'presence/' + otherUserUid);
      currentPresenceListener = onValue(presenceRef, (snapshot) => {
          if (currentChatId !== id) return; 
          if (!snapshot.exists()) {
              chatStatus.textContent = "";
              chatStatus.classList.remove("online");
              return;
          }
          
          const status = snapshot.val();
          
          if (status === true) {
              chatStatus.textContent = "Online";
              chatStatus.classList.add("online");
          } else if (typeof status === 'number') {
              chatStatus.textContent = `Last seen ${formatLastSeen(status)}`;
              chatStatus.classList.remove("online");
          } else {
              chatStatus.textContent = "";
              chatStatus.classList.remove("online");
          }
      });
  } else if (!currentChatIsGroup) {
      chatStatus.textContent = "User status unavailable";
  } else {
      chatStatus.textContent = "";
  }
  // --- End Presence Listener ---


  // --- Typing Indicator Listener (Unchanged) ---
  const typingRef = ref(db, "typing/" + id);
  
  currentTypingListener = onValue(typingRef, (snapshot) => {
      if (currentChatId !== id) { 
          return;
      }
      
      if(!snapshot.exists()) {
          typingIndicator.textContent = "";
          return;
      }
      
      const typingUsers = [];
      const now = Date.now();
      
      snapshot.forEach((child) => {
          const uid = child.key;
          const timestamp = child.val();
          
          if(uid !== currentUser.uid && (now - timestamp) < 2000) {
              const uname = chatMembers[uid] || "Someone";
              typingUsers.push(uname);
          }
      });
      
      if(typingUsers.length > 0) {
          if(typingUsers.length === 1) {
              const namePart = currentChatIsGroup ? typingUsers[0] : document.getElementById("chatName").textContent;
              typingIndicator.textContent = `${namePart} is typing...`.trim();
          } else if(typingUsers.length === 2) {
              typingIndicator.textContent = `${typingUsers.join(' and ')} are typing...`;
          } else {
              typingIndicator.textContent = `Multiple users are typing...`;
          }
      } else {
          typingIndicator.textContent = "";
      }
  });
  // --- END Typing Indicator Listener ---


  // mark messages as read and set lastRead
  await update(ref(db,"userChats/"+currentUser.uid+"/"+id), {
    unread: false,
    lastRead: Date.now()
  });

  if("serviceWorker" in navigator){
    navigator.serviceWorker.getRegistration().then(reg=>{
      if(!reg) return;
      reg.getNotifications({ tag: id }).then(list=>{
        list.forEach(n => n.close());
      }).catch(()=>{});
    }).catch(()=>{});
  }

  const msgRef=query(ref(db,"chats/"+id+"/messages"), limitToLast(100));
  currentListenerRef=msgRef;
  onChildAdded(msgRef,s=>renderMessage(s.val(), s.key));
}

// --- EDIT MESSAGE FUNCTION (NEW) ---
function editMessage(msgId, time, currentText) {
    if (Date.now() - time > EDIT_WINDOW_MS) {
        alert("Cannot edit message. The 10-minute editing window has expired.");
        return;
    }

    const newText = prompt("Edit your message:", currentText);

    if (newText && newText.trim() !== currentText.trim()) {
        const messageRef = ref(db, `chats/${currentChatId}/messages/${msgId}`);
        update(messageRef, {
            text: newText.trim(),
            edited: true,
            // Keep original timestamp
        }).catch(error => {
            alert("Error updating message: " + error.message);
        });
    }
}

// --- UPDATE MESSAGE STATUS (NEW) ---
function updateMessageStatus(msgId, msgTime, lastReadTime, recipientUid) {
    if (!msgId || !msgTime || !lastReadTime) return;

    const statusIcon = document.getElementById(`status-icon-${msgId}`);
    if (!statusIcon) return;
    
    // Check if the recipient has read the message (if their lastRead is > our message time)
    if (lastReadTime >= msgTime) {
        statusIcon.classList.add('read');
    } else {
        statusIcon.classList.remove('read');
    }
    
    // Check if message was edited (listen for changes on the message node itself)
    const messageRef = ref(db, `chats/${currentChatId}/messages/${msgId}`);
    onValue(messageRef, (snapshot) => {
        const messageData = snapshot.val();
        const msgDiv = document.getElementById(`msg-text-${msgId}`);
        if (messageData && msgDiv) {
            // Update text immediately if it has changed
            if (messageData.text !== msgDiv.textContent && !messageData.type) {
                 msgDiv.textContent = messageData.text; 
            }
            
            // Update edited indicator
            let indicator = msgDiv.querySelector('.edit-indicator');
            if (messageData.edited) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'edit-indicator';
                    msgDiv.appendChild(indicator);
                }
                indicator.textContent = '(edited)';
            } else if (indicator) {
                 indicator.remove();
            }
        }
    }, { onlyOnce: false }); // Keep this listener active to update the text/edit status
}

// --- RENDER MESSAGE (UPDATED FOR READ/EDIT) ---
function renderMessage(m, msgId){
  const isMe = m.sender === currentUser.uid;
  const div=document.createElement("div");
  div.classList.add("msg", isMe ? "me" : "them");
  div.dataset.id = msgId;
  div.dataset.time = m.time;

  if (m.type === 'image') {
      // Handle image message styling
      div.classList.add("media-only");
      div.innerHTML = `
          <div class="media-container">
              <img src="${m.text}" alt="Shared Image" onclick="window.open('${m.text}', '_blank')" />
          </div>
          <span class="timestamp">
              ${isMe ? `<span class="read-status-icon" id="status-icon-${msgId}">✓✓</span>` : ''}
              ${new Date(m.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
          </span>
      `;
  } else {
      let senderLabel="";
      if(currentChatIsGroup && !isMe){
          senderLabel=`<div class="sender">${chatMembers[m.sender] || "Unknown"}</div>`;
      }
      
      let editIndicator = m.edited ? `<span class="edit-indicator">(edited)</span>` : '';
      
      div.innerHTML = `
          ${senderLabel}
          <div id="msg-text-${msgId}">${m.text}${editIndicator}</div>
          <span class="timestamp">
              ${isMe ? `<span class="read-status-icon" id="status-icon-${msgId}">✓✓</span>` : ''}
              ${new Date(m.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
          </span>
      `;
      
      // Attach DBLCLICK handler for editing
      if (isMe) {
          div.ondblclick = () => editMessage(msgId, m.time, m.text);
      }
  }

  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Initial check for read status and set up listener for status updates
  if (isMe && otherUserUid && !currentChatIsGroup) {
      get(ref(db, `userChats/${otherUserUid}/${currentChatId}`)).then(snap => {
          const otherChatData = snap.val();
          const lastRead = otherChatData ? otherChatData.lastRead : 0;
          updateMessageStatus(msgId, m.time, lastRead, otherUserUid);
      });
  } else {
      // Still set up the general update listener for the edit status
      updateMessageStatus(msgId, m.time, 0, otherUserUid); 
  }
}


// --- REST OF THE CODE (UNCHANGED) ---

// ... (Rest of the functions: send, newDm, newGroup, etc. remain unchanged) ...


// --- SEND MESSAGE ---
document.getElementById("sendBtn").onclick=async()=>{
  const text=messageInput.value.trim();
  if(!currentChatId||(!text&&!replyTo))return;
  stopTyping();

  const msg={
    sender:currentUser.uid,
    time:Date.now(),
    text:text,
    replyTo:replyTo,
  };
  
  if (otherUserUid) {
      msg.seen = [currentUser.uid];
  }

  await push(ref(db,"chats/"+currentChatId+"/messages"),msg);
  messageInput.value="";
  replyTo=null;
  replyBar.style.display="none";

  const updates={
    lastMessageTime:msg.time,
    lastMessageText:text.length>50?text.substring(0,50)+"...":text,
  };
  await update(ref(db,"userChats/"+currentUser.uid+"/"+currentChatId),updates);
  
  const membersSnap = await get(ref(db, `chats/${currentChatId}/members`));
  let members = [];
  if (membersSnap.exists()) {
      members = Array.isArray(membersSnap.val()) ? membersSnap.val() : Object.keys(membersSnap.val());
  }

  // Update other users' chat list and mark as unread
  const updatePromises = members
    .filter(uid => uid !== currentUser.uid)
    .map(uid => 
        update(ref(db, "userChats/" + uid + "/" + currentChatId), {
            ...updates,
            unread: true,
            // lastRead is NOT updated for others when *we* send a message
        })
    );
    
  await Promise.all(updatePromises);
};


// --- SEND MEDIA URL ---
mediaBtn.onclick = async () => {
    if (!currentChatId || !currentUser) return;
    
    const url = prompt("Enter public URL for the image (e.g., from Imgur, your Pi server, etc.):");
    
    if (url && url.match(/\.(jpeg|jpg|gif|png|webp|svg)$/i)) {
        stopTyping(); 

        const msg = {
            sender: currentUser.uid,
            time: Date.now(),
            text: url,
            type: 'image',
            replyTo: replyTo,
        };
        
        if (otherUserUid) {
            msg.seen = [currentUser.uid];
        }

        await push(ref(db, "chats/" + currentChatId + "/messages"), msg);
        replyTo = null;
        replyBar.style.display = "none";

        const updates = {
            lastMessageTime: msg.time,
            lastMessageText: `🖼️ Image: ${url.length > 50 ? url.substring(0, 50) + '...' : url}`,
        };
        await update(ref(db, "userChats/" + currentUser.uid + "/" + currentChatId), updates);

        const membersSnap = await get(ref(db, `chats/${currentChatId}/members`));
        let members = [];
        if (membersSnap.exists()) {
            members = Array.isArray(membersSnap.val()) ? membersSnap.val() : Object.keys(membersSnap.val());
        }

        const updatePromises = members
            .filter(uid => uid !== currentUser.uid)
            .map(uid => 
                update(ref(db, "userChats/" + uid + "/" + currentChatId), {
                    ...updates,
                    unread: true,
                })
            );
            
        await Promise.all(updatePromises);
    } else if (url !== null) {
        alert("Invalid or missing image URL. Please enter a direct link ending in an image file extension.");
    }
};

// --- REST OF THE FUNCTIONS (Unchanged) ---
document.getElementById("backBtn").onclick=()=>show(chatListScreen);
document.getElementById("profileBtn").onclick=()=>{show(profileScreen);loadProfile();};
document.getElementById("profileBackBtn").onclick=()=>show(chatListScreen);
document.getElementById("adminBackBtn").onclick=()=>show(chatListScreen);
document.getElementById("adminBtn").onclick=()=>show(adminScreen);
document.getElementById("logoutBtn").onclick=()=>signOut(auth);
document.getElementById("message").oninput=startTyping;
document.getElementById("message").onkeydown=(e)=>{if(e.key==="Enter"&&!e.shiftKey){e.preventDefault();document.getElementById("sendBtn").click();}};

// NEW GROUP SETTINGS BUTTON HANDLER
settingsBtn.onclick = () => {
    groupSettingsMenu.style.display = groupSettingsMenu.style.display === 'block' ? 'none' : 'block';
};

// Hide menu when clicking outside (simple implementation)
document.addEventListener('click', (e) => {
    if (e.target !== settingsBtn && !groupSettingsMenu.contains(e.target)) {
        groupSettingsMenu.style.display = 'none';
    }
});

// NEW GROUP RENAME LOGIC
document.getElementById("renameGroupBtn").onclick = async () => {
    groupSettingsMenu.style.display = 'none';
    if (!currentChatIsGroup || !currentChatId) return alert("Not a group chat.");
    
    const newName = prompt("Enter new group name:");
    if (newName && newName.trim()) {
        const trimmedName = newName.trim();
        // 1. Update the chat name in the main chat node
        await update(ref(db, `chats/${currentChatId}`), { name: trimmedName });
        
        // 2. Update the chat name in every userChats node
        const chatSnap = await get(ref(db, `chats/${currentChatId}`));
        const members = Object.keys(chatSnap.val().members || {});

        const updatePromises = members.map(uid => 
            update(ref(db, `userChats/${uid}/${currentChatId}`), { name: trimmedName })
        );
        
        await Promise.all(updatePromises);
        
        document.getElementById("chatName").textContent = trimmedName;
        alert("Group renamed successfully!");
        loadChats(); // Refresh chat list
    }
};

// NEW ADD MEMBERS LOGIC
document.getElementById("addMembersBtn").onclick = async () => {
    groupSettingsMenu.style.display = 'none';
    if (!currentChatIsGroup || !currentChatId) return alert("Not a group chat.");
    
    const usernameInput = prompt("Enter username of the user to add:");
    if (!usernameInput || !usernameInput.trim()) return;
    const normalizedUsername = usernameInput.trim().toLowerCase();

    // 1. Find UID from username
    const usernameSnap = await get(ref(db, `usernames/${normalizedUsername}`));
    if (!usernameSnap.exists()) {
        return alert(`User "${normalizedUsername}" not found.`);
    }
    const targetUid = usernameSnap.val();

    // 2. Check if user is already a member
    const chatSnap = await get(ref(db, `chats/${currentChatId}`));
    const members = chatSnap.val().members || {};
    
    if (members[targetUid]) {
        return alert(`User "${normalizedUsername}" is already a member.`);
    }

    const chatName = document.getElementById("chatName").textContent;

    // 3. Add member to the main chat
    const updates = {};
    updates[`members/${targetUid}`] = true; 
    await update(ref(db, `chats/${currentChatId}`), updates);

    // 4. Create chat entry for the new user
    await set(ref(db, `userChats/${targetUid}/${currentChatId}`), {
        name: chatName,
        isGroup: true,
        lastMessageTime: Date.now(),
        lastMessageText: `You were added to the group: ${chatName}.`,
        unread: true,
    });
    
    // 5. Send a system message to the chat
    const memberName = await getUserDisplayName(targetUid);
    const systemMessage = {
        sender: 'system',
        time: Date.now(),
        text: `${chatMembers[currentUser.uid] || 'A member'} added ${memberName} to the group.`,
    };
    await push(ref(db, `chats/${currentChatId}/messages`), systemMessage);

    alert(`${memberName} added to the group.`);
};

// --- NEW DM / NEW GROUP LOGIC (Unchanged) ---
document.getElementById("newDmBtn").onclick=async()=>{
  const username=prompt("Enter target user's username:");
  if(!username||!username.trim())return;
  const normalizedUsername=username.trim().toLowerCase();
  if(normalizedUsername===currentUser.displayName.toLowerCase()||normalizedUsername===currentUser.email.split('@')[0].toLowerCase())return alert("Cannot DM yourself.");

  const usernamesSnap=await get(ref(db,"usernames/"+normalizedUsername));
  if(!usernamesSnap.exists())return alert("User not found.");
  const targetUid=usernamesSnap.val();

  // 1. Check for existing DM chat
  const myChatsSnap=await get(query(ref(db,"userChats/"+currentUser.uid),orderByChild("isGroup"),equalTo(false)));
  let existingChatId=null;
  myChatsSnap.forEach(chatChild=>{
    const chatData=chatChild.val();
    if(chatData.otherUid===targetUid){
      existingChatId=chatChild.key;
    }
  });

  if(existingChatId){
    openChat(existingChatId,username);
    return;
  }

  // 2. Create new chat
  const newChatRef=push(ref(db,"chats"));
  const newChatId=newChatRef.key;

  const myDisplayName=await getUserDisplayName(currentUser.uid);

  // Set chat details
  await set(newChatRef,{
    isGroup:false,
    members:{[currentUser.uid]:true, [targetUid]:true},
  });

  // Set userChats entry for sender
  await set(ref(db,"userChats/"+currentUser.uid+"/"+newChatId),{
    name:username,
    isGroup:false,
    otherUid:targetUid,
    lastMessageTime:Date.now(),
    lastRead:Date.now()
  });

  // Set userChats entry for recipient
  await set(ref(db,"userChats/"+targetUid+"/"+newChatId),{
    name:myDisplayName,
    isGroup:false,
    otherUid:currentUser.uid,
    lastMessageTime:Date.now(),
  });
  
  loadChats();
  openChat(newChatId,username);
};

document.getElementById("groupBtn").onclick=async()=>{
  const groupName=prompt("Enter new group name:");
  if(!groupName||!groupName.trim())return;
  
  const newChatRef=push(ref(db,"chats"));
  const newChatId=newChatRef.key;
  const memberUidObject={[currentUser.uid]:true};

  await set(newChatRef,{
    isGroup:true,
    name:groupName.trim(),
    members:memberUidObject
  });

  await set(ref(db,"userChats/"+currentUser.uid+"/"+newChatId),{
    name:groupName.trim(),
    isGroup:true,
    lastMessageTime:Date.now(),
    lastRead:Date.now()
  });

  loadChats();
  openChat(newChatId,groupName.trim());
};

// --- PROFILE LOGIC (Unchanged) ---
async function loadProfile() {
    document.getElementById("currentUsernameDisplay").textContent = currentUser.email.split('@')[0].toLowerCase();
    
    const uSnap = await get(ref(db, "users/" + currentUser.uid));
    if (uSnap.exists()) {
        const userData = uSnap.val();
        document.getElementById("firstName").value = userData.firstName || '';
        document.getElementById("lastName").value = userData.lastName || '';
    } else {
        document.getElementById("firstName").value = '';
        document.getElementById("lastName").value = '';
    }
}

document.getElementById("saveNameBtn").onclick = async () => {
    const firstName = document.getElementById("firstName").value.trim();
    const lastName = document.getElementById("lastName").value.trim();
    
    const fullName = [firstName, lastName].filter(n => n).join(' ');
    
    try {
        await update(ref(db, "users/" + currentUser.uid), {
            firstName: firstName,
            lastName: lastName,
            fullName: fullName,
            displayName: fullName || currentUser.email.split('@')[0]
        });
        alert("Name saved successfully!");
    } catch (e) {
        alert("Error saving name: " + e.message);
    }
};

document.getElementById("changePasswordBtn").onclick = async () => {
    const newPassword = document.getElementById("newPassword").value;
    const confirmPassword = document.getElementById("confirmPassword").value;

    if (newPassword !== confirmPassword) {
        return alert("New password and confirmation do not match.");
    }
    if (newPassword.length < 6) {
        return alert("Password must be at least 6 characters long.");
    }

    try {
        await updatePassword(auth.currentUser, newPassword);
        alert("Password updated successfully!");
        document.getElementById("newPassword").value = "";
        document.getElementById("confirmPassword").value = "";
    } catch (e) {
        alert("Error changing password. You may need to log in again: " + e.message);
    }
};


// --- ADMIN LOGIC (Unchanged) ---

document.getElementById("adminSearchBtn").onclick = async () => {
    const username = document.getElementById("adminSearchInput").value.trim().toLowerCase();
    if (!username) return alert("Enter a username.");

    const uidSnap = await get(ref(db, `usernames/${username}`));
    if (!uidSnap.exists()) {
        document.getElementById("userInfo").style.display = 'none';
        return alert(`User "${username}" not found.`);
    }

    currentTargetUid = uidSnap.val();
    const userSnap = await get(ref(db, `users/${currentTargetUid}`));
    const userChatsSnap = await get(ref(db, `userChats/${currentTargetUid}`));
    
    if (userSnap.exists()) {
        const userData = userSnap.val();
        
        document.getElementById("adminUid").textContent = currentTargetUid;
        document.getElementById("adminUsername").textContent = userData.username || 'N/A';
        document.getElementById("adminEmail").textContent = userData.email || 'N/A';
        document.getElementById("adminFullName").textContent = userData.fullName || 'N/A';
        
        // Fetch last seen/online status
        const presenceSnap = await get(ref(db, `presence/${currentTargetUid}`));
        document.getElementById("adminLastSeen").textContent = formatLastSeen(presenceSnap.val());
        
        // Load Chat Logs (Metadata)
        const chatLogDiv = document.getElementById("adminChatLog");
        chatLogDiv.innerHTML = '';
        
        if (userChatsSnap.exists()) {
            userChatsSnap.forEach(chatChild => {
                const chatData = chatChild.val();
                const div = document.createElement('div');
                div.className = 'audit-item';
                div.innerHTML = `
                    <strong>Chat: ${chatData.name} (${chatData.isGroup ? 'Group' : 'DM'})</strong>
                    <p>ID: ${chatChild.key}</p>
                    <p>Last Message: ${chatData.lastMessageText || 'None'}</p>
                    <p>Last Active: ${formatLastSeen(chatData.lastMessageTime)}</p>
                `;
                chatLogDiv.appendChild(div);
            });
        } else {
            chatLogDiv.textContent = 'No chat history found.';
        }

        document.getElementById("userInfo").style.display = 'block';
    } else {
        alert("User data exists in /usernames but not /users (malformed account).");
    }
};

document.getElementById("deleteAccountBtn").onclick = async () => {
    if (!isAdmin || !currentTargetUid) return alert("Access denied or no user selected.");

    if (!confirm(`ARE YOU ABSOLUTELY SURE you want to DELETE account for UID: ${currentTargetUid}? This is irreversible.`)) return;

    try {
        const userSnap = await get(ref(db, `users/${currentTargetUid}`));
        const username = userSnap.val().username;

        // 1. Remove from /usernames
        await remove(ref(db, `usernames/${username}`));
        
        // 2. Remove from /users
        await remove(ref(db, `users/${currentTargetUid}`));
        
        // 3. Remove chat list metadata from /userChats (cannot remove all chat messages as they belong to the chat, not the user)
        await remove(ref(db, `userChats/${currentTargetUid}`));
        
        // 4. Remove presence data
        await remove(ref(db, `presence/${currentTargetUid}`));
        
        // NOTE: Deleting the Firebase Auth user is difficult from the client side without being that user. 
        // We skip this step, assuming this is an admin tool for cleaning up DB references. 
        // If this were a true admin panel, this step would require a server/cloud function.

        alert(`Account for ${username} (UID: ${currentTargetUid}) successfully purged from database.`);
        document.getElementById("userInfo").style.display = 'none';
        document.getElementById("adminSearchInput").value = '';

    } catch (e) {
        alert("Admin Deletion Error: " + e.message);
    }
};

// --- UNREAD CHAT LISTENER (Unchanged) ---
function listenForUnread(){
    const userChatsRef = ref(db, `userChats/${currentUser.uid}`);
    onValue(userChatsRef, (snapshot) => {
        if (!snapshot.exists()) return;

        snapshot.forEach(chatChild => {
            const chatId = chatChild.key;
            const chatData = chatChild.val();
            const chatItemDiv = document.querySelector(`.chatItem[data-id="${chatId}"]`);

            if (chatItemDiv) {
                if (chatData.unread) {
                    chatItemDiv.classList.add('unread');
                } else {
                    chatItemDiv.classList.remove('unread');
                }
            }
        });
    });
}
</script>
</body>
</html>
